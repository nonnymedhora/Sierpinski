<!DOCTYPE html>
<!--
	Mandelbrot-Fraktal-Generator in JavaScript
	Autor: Stefan Bion
	URL: http://www.stefanbion.de/fraktal-generator/mandelbrot.htm

	Dieses JavaScript-Programm benutzt das canvas-Element zum Zeichnen der Mandelbrotmenge.
	Zur Ausführung wird ein Browser mit JavaScript und HTML5 benötigt.
	Der Sourcecode darf ohne Einschränkung frei verwendet werden.
-->
<html>
	<head>
		<meta http-equiv="content-type" content="text/html; charset=ISO-8859-15">
		<meta name="keywords" content="Apfelmännchen, Mandelbrot, Mandelbrotmenge, Mandelbrot Set, Fraktal, Fraktalgrafik, Fractal, Fractal Graphics, Fraktal-Generator, fractal generator, javascript">
			<title>Mandelbrot-Fraktal-Generator in JavaScript - www.StefanBion.de</title>

		<style type="text/css">
			body {
				font-family:Arial,sans-serif;
				font-size:10pt;
				line-height:1.5em;
				color:#000000;
				background-color:#EEEEEE;
			}
			sub { 
				line-height:0;
				position:relative;
				top:+0.3em;
			}
			sup { 
				line-height:0;
				position:relative;
				top:-0.3em;
			}
			canvas {
				outline:1px solid black;
				cursor:crosshair;
			}
			fieldset {
				display:inline-block;
				margin:0px 0px 5px 0px;
				padding:2px 4px 2px 4px;
				border:1px solid black;
				background-color:#DDDDDD;
			}
			form * {
				vertical-align:middle;
			}
			.label {
			}
			form input, select {
				padding:0;
			}
			/* Buttons */
			form input[type=button] {
				padding:0px 4px 0px 4px;
				margin:0;
				height:22px;
				line-height:0px;
			}
			/* Checkboxen */
			form input[type=checkbox] {
				margin:0;
			}
			form input[type=button]::-moz-focus-inner, 
			form input[type=color]::-moz-focus-inner { 
				border:none;
				padding:0;
			}
			/* Color Picker */
			form input[type=color] {
				-webkit-appearance:none;
				-moz-appearance:none;
				outline:1px solid #000000;
				border:none;
				margin:1px 2px 1px 2px;
				width:18px;
				height:18px;
			}
			input[type="color"]::-moz-color-swatch {
				border:none;
			}
			input[type="color"]::-webkit-color-swatch-wrapper {
				padding:0;
			}
			input[type="color"]::-webkit-color-swatch {
				border:none;
			}
			#duration {
				color:blue;
			}
			#magnification {
				color:green;
			}
			span.formula {
				padding:1px 2px 1px 2px;
				border:1px dotted #969696;
			}
			span.input {
				padding:0px 4px 0px 4px;
				background-color:#FFFFFF;
				border:1px solid #969696;
			}
			span.button {
				padding:0px 4px 0px 4px;
				background-color:#E0E0E0;
				border:1px solid #565656;
			}
		</style>

		<script type="text/javascript">

			"use strict";

			  /////////////////////////
			 // Parameterverwaltung //
			/////////////////////////

			//
			// Parameter-Objekt
			//
			var g_par =
			{
				// Fraktal-Parameter
				reMin: -2.15,
				reMax: 0.85,
				imMin: -1.125,
				imMax: 1.125,
				itMax: 200,
				escRadius: 2,
				smoothing: false,

				// Grafik-Parameter
				imgWidth: 1200,
				imgHeight: 900,
				pxInterpolation: 1,
				colorMode: 'gradient2',
				colors: [ 0xFFFFFF, 0x000000, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF ],
				linearity: 1,
				linRange: 20,
				colorCount: 2,
				colorCompress: false,
				colorInvert: false,
				repCount: 1,
				cyclePalette: false,
				reduceHalo: false,
				colorImax: 0x000000
			};

			var g_nColorsAvailable = g_par.colors.length;
			var g_parDefault = CloneParameters(g_par);
			g_parDefault.escRadius = 2, g_parDefault.smoothing = false, g_parDefault.linearity = 1, g_parDefault.linRange = 20, g_parDefault.colorCompress = false;

			//
			// Parameter eines Fraktalgrafik-Beispiels laden
			//
			function LoadExample(value)
			{
				switch(value)
				{
					case 'apple-bw':     FillParametersIntoForm(undefined, -2, 2, -2, 2, 200, 2, false, 1200, 900, 3, 'gradient2', [ 0xFFF9F2, 0x402000, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF ], 1, 20, 2, false, false, 1, false, false, 0x000000); break;
					case 'apple-cl':     FillParametersIntoForm(undefined, -2.15, 0.85, -1.125, 1.125, 200, 10, true, 1200, 900, 1, 'gradient3', [ 0x008000, 0xFFFFFF, 0xFF0080, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF ], 3, 20, 0, true, false, 1, false, false, 0x000000); break;
					case 'spiral-bw':    FillParametersIntoForm(undefined, -0.7956823317837173, -0.79068056677067, -0.16275319091510096, -0.1590018671553155, 200, 2, false, 1200, 900, 3, 'gradient2', [ 0xFFF9F2, 0x402000, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF ], 1, 20, 2, false, false, 1, false, false, 0x000000); break;
					case 'spiral-cl':    FillParametersIntoForm(undefined, -0.7956823317837173, -0.79068056677067, -0.16275319091510096, -0.1590018671553155, 200, 5, true, 1200, 900, 1, 'gradient3', [ 0xFF0000, 0xFFFF00, 0xFF00FF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF ], 3, 20, 0, false, false, 1, false, false, 0x000000); break;
					case 'star':         FillParametersIntoForm(undefined, 0.33462499132396617, 0.33526096925876003, -0.04694933386601494, -0.046474913189289514, 200, 5, true, 1200, 900, 1, 'gradient7', [ 0xFF0000, 0xFFFF00, 0x00FF00, 0x00FFFF, 0x0000FF, 0xFF00FF, 0xFF0000 ], 1, 20, 0, false, true, 1, false, true, 0x000000); break;
					case 'tree':         FillParametersIntoForm(undefined, -0.9128697129629628, -0.9110330462962962, -0.23554590740740738, -0.23416840740740738, 300, 2, false, 1200, 900, 3, 'gradient2', [ 0x000000, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF ], 1, 20, 2, false, true, 1, false, false, 0x00A2F6); break;
					case 'flower':       FillParametersIntoForm(undefined, -1.7542145512898188, -1.7542141698200924, 0.013646785100301631, 0.013647071202596553, 200, 5, true, 1200, 900, 1, 'gradient3', [ 0x008000, 0xFFFFFF, 0xFF0080, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF ], 4, 20, 0, true, false, 1, false, false, 0xBB005E); break;
					case 'butterfly':    FillParametersIntoForm(undefined, -1.2568052782367904, -1.2568052766328397, 0.379736989999753, 0.3797369912027161, 20000, 10, true, 1200, 900, 3, 'gradient3', [ 0xFF80C0, 0xFFFFFF, 0x66B3FF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF ], 4, 32, 0, false, false, 40, true, false, 0x000000); break;
					case 'furryjulia':   FillParametersIntoForm(undefined, -0.37262539975113096, -0.3726253994754442, -0.6057065296066647, -0.6057065293998997, 10000, 2, false, 1200, 900, 3, 'gradient6', [ 0x000000, 0xFF8000, 0xFFFF00, 0xFFFFFF, 0x004DBF, 0x000000, 0xFFFFFF ], 1, 20, 0, false, false, 3, false, false, 0x000000); break;
					case 'goldenjulia':  FillParametersIntoForm(undefined, -0.015508846869103957, -0.015508846836170006, 1.0206523303921704, 1.0206523304168709, 100000, 10, true, 1200, 900, 3, 'gradient7', [ 0x000000, 0x808080, 0xFFFFFF, 0x000000, 0xFF8000, 0xFFFF00, 0xFFFFFF ], 4, 74, 0, true, false, 1, false, false, 0xFFFFFF); break;
					case 'burningjulia': FillParametersIntoForm(undefined, -1.0284476966738116, -1.0284476966724156, 0.3614611972926626, 0.3614611972937095, 1622, 10, true, 1200, 900, 3, 'gradient7', [ 0x000000, 0x808080, 0xFFFFFF, 0x000000, 0xFF8000, 0xFFFF00, 0xFE6C01], 4, 30, 0, true, false, 6, true, true, 0x000000); break;
					default: return;
				}
				Draw();
			}

			//
			// Default-Parameter (assoziatives Array von Objekten)
			//
			var g_colDefault =
			{
				gradient2:  { colors: [ 0xFFF9F2, 0x402000, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF ], linearity: 1, linRange: 20, colorCount:  2, colorCompress: false, colorInvert: false, repCount: 1, cyclePalette: false, reduceHalo: false, colorImax: 0x000000 }, // Antik
				gradient3:  { colors: [ 0x008000, 0xFFFFFF, 0xFF0080, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF ], linearity: 3, linRange: 20, colorCount:  0, colorCompress: false, colorInvert: false, repCount: 1, cyclePalette: false, reduceHalo: false, colorImax: 0x000000 }, // Tricolore
				gradient4:  { colors: [ 0x000000, 0x8000FF, 0x80FFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF ], linearity: 3, linRange: 20, colorCount:  0, colorCompress: false, colorInvert: false, repCount: 1, cyclePalette: false, reduceHalo: false, colorImax: 0x000000 }, // Electric
				gradient5:  { colors: [ 0x000000, 0x800000, 0xFF0000, 0xFFFF00, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF ], linearity: 3, linRange: 20, colorCount:  0, colorCompress: false, colorInvert: false, repCount: 1, cyclePalette: false, reduceHalo: false, colorImax: 0x000000 }, // Fire
				gradient6:  { colors: [ 0xFFFFFF, 0x80D6FF, 0xE0B1E4, 0xC6F0C6, 0xF2F2A8, 0xFFFFFF, 0xFFFFFF ], linearity: 3, linRange: 20, colorCount:  0, colorCompress: false, colorInvert: false, repCount: 1, cyclePalette: false, reduceHalo: false, colorImax: 0xFFFFFF }, // Pastell
				gradient7:  { colors: [ 0x000000, 0x004891, 0x77BBFF, 0xFFFFFF, 0xFFFF00, 0xFF8000, 0x000000 ], linearity: 3, linRange: 20, colorCount:  0, colorCompress: true,  colorInvert: false, repCount: 2, cyclePalette: false, reduceHalo: false, colorImax: 0x000000 }, // Ultra Fractal
				random:     { colors: [ 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF ], linearity: 3, linRange: 20, colorCount:  0, colorCompress: false, colorInvert: false, repCount: 1, cyclePalette: false, reduceHalo: false, colorImax: 0x000000 }
			};

			//
			// Setzt die Default-Farbparameter abhängig vom gewählten Farbmodus.
			// Zuvor werden die aktuellen Farbparameter des vorherigen Farbmodus gesichert.
			//
			function SetDefaultColors()
			{
				// Alte Default-Farbparameter sichern:

				for (var i = 0; i < g_nColorsAvailable; i++)
					g_colDefault[g_par.colorMode].colors[i] = HexColorToNumber($('color' + (i + 1)).value);
				g_colDefault[g_par.colorMode].linearity = parseInt($('linearity').value, 10);
				g_colDefault[g_par.colorMode].linRange = parseInt($('linRange').value, 10);
				g_colDefault[g_par.colorMode].colorCount = parseInt($('colorCount').value, 10);
				g_colDefault[g_par.colorMode].colorCompress = $('colorCompress').checked;
				g_colDefault[g_par.colorMode].colorInvert = $('colorInvert').checked;
				g_colDefault[g_par.colorMode].repCount = parseInt($('repCount').value, 10);
				g_colDefault[g_par.colorMode].cyclePalette = $('cyclePalette').checked;
				g_colDefault[g_par.colorMode].reduceHalo = $('reduceHalo').checked;
				g_colDefault[g_par.colorMode].colorImax = HexColorToNumber($('colorImax').value);

				// Neue Default-Farbparameter ins Formular schreiben:

				g_par.colorMode = $('colorMode').value;

				for (var i = 0; i < g_nColorsAvailable; i++)
					$('color' + (i + 1)).value = NumberToHexColor(g_colDefault[g_par.colorMode].colors[i]);
				$('linearity').value = g_colDefault[g_par.colorMode].linearity;
				$('linRange').value = g_colDefault[g_par.colorMode].linRange;
				$('colorCount').value = g_colDefault[g_par.colorMode].colorCount;
				$('colorCompress').checked = g_colDefault[g_par.colorMode].colorCompress;
				$('colorInvert').checked = g_colDefault[g_par.colorMode].colorInvert;
				$('repCount').value = g_colDefault[g_par.colorMode].repCount;
				$('cyclePalette').checked = g_colDefault[g_par.colorMode].cyclePalette;
				$('reduceHalo').checked = g_colDefault[g_par.colorMode].reduceHalo;
				$('colorImax').value = NumberToHexColor(g_colDefault[g_par.colorMode].colorImax);

				EnableControls();
			}

			  /////////////////////
			 // Initialisierung //
			/////////////////////

			// Canvas
			var g_imgElement;
			var g_imgContext;

			var g_bDrawing = false;

			//
			// Initialisierung - muss zu Beginn einmalig aufgerufen werden
			//
			function Init()
			{
				// Event-Handler
				$('image').addEventListener('mousedown', OnMouseDown, false);
				$('image').addEventListener('mouseup', OnMouseUp, false);
				$('image').addEventListener('mousemove', OnMouseMove, false);

				// Formulardaten
				FillParametersIntoForm();

				// Canvas
				g_imgElement = $('image');
				g_imgContext = g_imgElement.getContext('2d');

				// Localization
				InitLocals();
			}

			//
			// Initialisierung der sprachenabhängigen Elemente
			//

			var g_lang = navigator.language || navigator.userLanguage;
			var g_english = (g_lang.substr(0, 2) !== 'de');
			//alert('navigator.language='+navigator.language+'\nnavigator.userLanguage='+navigator.userLanguage+'\ng_english='+g_english);

			// Strings
			var g_strMaxNumberOfIterations = g_english ? 'Maximum number of iterations' : 'Maximale Anzahl von Iterationen';
			var g_strPresentInTheImageSurrounding = g_english ? 'Present in the image (surrounding)' : 'Im Bild vorkommend (Umgebung)';
			var g_strMandelbrotSetPresent = g_english ? 'Mandelbrot set present' : 'Mandelbrotmenge enthalten';
			var g_strYes = g_english ? 'Yes' : 'Ja';
			var g_strNo = g_english ? 'No' : 'Nein';
			var g_strMagnification = g_english ? 'M' : 'V';
			var g_strColors = g_english ? 'Colors' : 'Farben';
			var g_strRandom = g_english ? 'Random' : 'Zufall';
			var g_strColorForGradient1 = g_english ? 'Color ' : '';
			var g_strColorForGradient2 = g_english ? ' for the color gradient' : '. Farbe für den Farbverlauf';
			var g_strDraw = g_english ? 'Draw' : 'Zeichnen';
			var g_strStop = g_english ? 'Stop' : 'Stop';

			function InitLocals()
			{
				// Anleitungstext
				$('helpGerman').style.display = g_english ? 'none' : 'block';
				$('helpEnglish').style.display = g_english ? 'block' : 'none';

				// Formular
				$('reLabel').innerHTML = g_english ? 'Re:' : 'Re:';
				$('reMin').title = g_english ? 'Start value of the real part' : 'Startwert des Realteils';
				$('reMax').title = g_english ? 'End value of the real part' : 'Endwert des Realteils';
				$('imLabel').innerHTML = g_english ? 'Im:' : 'Im:';
				$('imMin').title = g_english ? 'Start value of the imaginary part' : 'Startwert des Imaginärteils';
				$('imMax').title = g_english ? 'End value of the imaginary part' : 'Endwert des Imaginärteils';
				$('itMaxLabel').innerHTML = g_english ? 'I<sub>max</sub>:' : 'I<sub>max</sub>:';
				$('itMax').title = g_english ? 'Maximum number of iterations' : 'Maximale Anzahl von Iterationen';
				$('escRadiusLabel').innerHTML = g_english ? 'Rad:' : 'Rad:';
				$('escRadius').title = g_english ? 'Escape radius (should be at least 4 with activated DeBanding)' : 'Fluchtradius (sollte bei aktiviertem DeBanding mindestens 4 betragen)';
				$('smoothingLabel').innerHTML = g_english ? 'DeBanding:' : 'DeBanding:';
				$('smoothing').title = g_english ? 'Smoothen color gradients' : 'Farbübergänge glätten';
				$('duration').innerHTML = g_english ? 't=?.???s' : 't=?.???s';
				$('duration').title = g_english ? 'Required time to calculate\nand display the fractal image' : 'Benötigte Zeitdauer zur Berechnung\nund Anzeige der Fraktalgrafik';
				$('magnification').innerHTML = g_english ? 'M=?.??&times;10<sup>?</sup>' : 'V=?.??&times;10<sup>?</sup>';
				$('magnification').title = g_english ? 'Magnification factor' : 'Vergrößerungsfaktor';
				$('imgWidth').title = g_english ? 'Horizontal size of the fractal image in pixels' : 'Horizontale Größe der zu erzeugenden Fraktalgrafik in Pixeln';
				$('imgHeight').title = g_english ? 'Vertical size of the fractal image in pixels' : 'Vertikale Größe der zu erzeugenden Fraktalgrafik in Pixeln';
				$('pxInterpolation').title = g_english ? 'Pixel interpolation: Side length of a virtual square\nwhose pixels are interpolated to one pixel.' : 'Pixel-Interpolation: Anzahl von Pixeln, die die Seitenlänge eines virtuellen Quadrates\nbilden, dessen Pixel zu einem Pixel interpoliert werden.';
				$('colorMode').title = g_english ? 'Selection of the color palette to be used' : 'Auswahl der zu verwendenden Farbpalette';
				$('linearity').title = g_english ? 'Linearity of the color gradient:\nlin = linear\nsin = sinus-shaped\nauto = automatical\nlog = logarithmic\ngam = gamma\ntanh = hyperbolic tangent' : 'Linearität des Farbverlaufs:\nlin = linear\nsin = sinusförmig\nauto = automatisch\nlog = logarithmisch\ngam = Gamma\ntanh = Tangens Hyperbolicus';
				$('linRange').title = g_english ? 'Value for linearity "log", "gam" and "tanh"' : 'Wert für Linearität "log", "gam" und "tanh"';
				$('colorCountLabel').innerHTML = g_english ? 'Num:' : 'Anz:';
				$('colorCount').title = g_english ? 'Number of distinct colors to be displayed (0 = all)' : 'Anzahl der darzustellenden unterschiedlichen Farben (0 = alle)';
				$('colorCompressLabel').innerHTML = g_english ? 'Cmp:' : 'Kmp:';
				$('colorCompress').title = g_english ? 'Compress color palette, i.e. show all colors of the palette in the image' : 'Farbpalette komprimieren, d.h. alle Farben der Palette im Bild unterbringen';
				$('colorInvertLabel').innerHTML = g_english ? 'Inv:' : 'Umk:';
				$('colorInvert').title = g_english ? 'Invert the order of the colors of the selected palette' : 'Reihenfolge der Farben der gewählten Palette umkehren';
				$('repCountLabel').innerHTML = g_english ? 'Rep:' : 'Wdh:';
				$('repCount').title = g_english ? 'Number of repetitions of the color palette (must be at least 1)' : 'Anzahl der Wiederholungen der Farbpalette (muss mindestens 1 sein)';
				$('cyclePaletteLabel').innerHTML = g_english ? 'Alt:' : 'Alt:';
				$('cyclePalette').title = g_english ? 'Alternate the direction of the color palette\n(only effective with Rep > 1)' : 'Richtung der Farbpalette alternieren\n(nur wirksam bei Wdh > 1)';
				$('reduceHaloLabel').innerHTML = g_english ? 'DeHalo:' : 'DeHalo:';
				$('reduceHalo').title = g_english ? 'Reduce color fringes' : 'Farbsäume reduzieren';
				$('colorImaxLabel').innerHTML = g_english ? 'I<sub>max</sub>:' : 'I<sub>max</sub>:';
				$('colorImax').title = g_english ? 'Color for iteration boundary' : 'Farbe für Iterationsgrenze';
				$('historyBack').title = g_english ? 'Backward: Loads the parameters of the previously drawn image' : 'Zurück: Lädt die Parameter des zuletzt gezeichneten Bildes';
				$('historyForward').title = g_english ? 'Forward: Loads the parameters of the next drawn image' : 'Vorwärts: Lädt die Parameter des danach gezeichneten Bildes';
				$('drawButton').value = g_english ? 'Draw' : 'Zeichnen';
				$('drawButton').title = g_english ? 'Draws the fractal image using the current parameters' : 'Zeichnet die Grafik mit den angegebenen Parametern';
				$('zoomLabel').innerHTML = g_english ? 'Zoom:' : 'Zoom:';
				$('zoomOutButton').title = g_english ? 'Zooms out of the image by the entered factor' : 'Zoomt um den angegebenen Faktor aus dem Bild heraus';
				$('zoomInButton').title = g_english ? 'Zooms into the image by the entered factor' : 'Zoomt um den angegebenen Faktor in das Bild hinein';
				$('zoomFactor').title = g_english ? 'Zoom factor' : 'Zoom-Faktor';
				$('moveLabel').innerHTML = g_english ? ' Move' : 'Verschieben:';
				$('moveLeftButton').title = g_english ? 'Moves the image section to the left by the entered percentage value' : 'Verschiebt den Bildausschnitt um den angegebenen Prozentwert nach links';
				$('moveRightButton').title = g_english ? 'Moves the image section to the right by the entered percentage value' : 'Verschiebt den Bildausschnitt um den angegebenen Prozentwert nach rechts';
				$('moveUpButton').title = g_english ? 'Moves the image section up by the entered percentage value' : 'Verschiebt den Bildausschnitt um den angegebenen Prozentwert nach oben';
				$('moveDownButton').title = g_english ? 'Moves the image section down by the entered percentage value' : 'Verschiebt den Bildausschnitt um den angegebenen Prozentwert nach unten';
				$('movePercent').title = g_english ? 'Percentage value by which the image section will be moved' : 'Prozentwert, um den der Bildausschnitt verschoben werden soll';
				$('linkButton').value = g_english ? 'Link' : 'Link';
				$('linkButton').title = g_english ? 'Create hyperlink to this image' : 'Link zu dieser Grafik erzeugen';
				$('savePngButton').title = g_english ? 'Save image as PNG file' : 'Grafik als PNG-Datei abspeichern';
				$('saveTxtButton').title = g_english ? 'Save parameters as text file' : 'Parameter als Textdatei abspeichern';
				$('readTxtButton').title = g_english ? 'Read parameters from text file' : 'Textdatei mit Parametern einlesen';
				$('examplesLabel').innerHTML = g_english ? 'Examples:' : 'Beispiele:';
				$('example').title = g_english ? 'Here you can select some example fractals.\nPlease click "Draw" afterwards!' : 'Hier stehen einige Beispiel-Fraktale zur Auswahl.\nBitte anschließend &quot;Zeichnen&quot; anklicken!';
				$('readTxtFileLabel').innerHTML = g_english ? 'Read text file' : 'Textdatei einlesen';
				$('allParametersLabel').innerHTML = g_english ? 'All parameters' : 'Alle Parameter';
				$('onlySelectedParametersLabel').innerHTML = g_english ? 'Only selected parameters:' : 'Nur ausgewählte Parameter:';
				$('fractalParametersLabel').innerHTML = g_english ? ' Fractal parameters (topmost line)' : ' Fraktal-Parameter (oberste Zeile)';
				$('onlyCoordinatesLabel').innerHTML = g_english ? ' Only the coordinates (Re, Im)' : ' Nur die Koordinaten (Re, Im)';
				$('graphicsParametersLabel').innerHTML = g_english ? ' Graphics parameters (middle line)' : ' Grafik-Parameter (mittlere Zeile)';
				$('onlyColorsLabel').innerHTML = g_english ? ' Only the colors' : ' Nur die Farben';
				$('okReadTxtButton').value = g_english ? 'OK' : 'OK';
				$('cancelReadTxtButton').value = g_english ? 'Cancel' : 'Abbrechen';
			}

			//
			// Setzt die Größe der "Leinwand" für die Grafik
			//
			function SetCanvas()
			{
				// Größe des canvas-Elements nur setzen, wenn abweichend zu Parametern,
				// da sonst der Bildinhalt gelöscht wird.

				if($('image').width != g_par.imgWidth)
					$('image').width = g_par.imgWidth;
				if($('image').height != g_par.imgHeight)
					$('image').height = g_par.imgHeight;
			}

			  ////////////////////////////////////////
			 // History (Vor- und Zurück-Funktion) //
			////////////////////////////////////////

			// History-Array
			var g_history = [];
			var g_historyIndex = -1;

			//
			// Fügt der History einen Eintrag hinzu.
			//
			function HistoryAdd()
			{
				if(g_historyIndex == g_history.length - 1)
				{
					if(g_historyIndex == -1 || !EqualParameters(g_par, g_history[g_historyIndex]))
					{
						g_history.push(CloneParameters(g_par));
						g_historyIndex++;
					}
				}
				else
				{
					if(!EqualParameters(g_par, g_history[g_historyIndex]))
					{
						while(g_history.length - 1 > g_historyIndex) delete g_history.pop();
						g_history.push(CloneParameters(g_par));
						g_historyIndex++;
					}
				}
			}

			//
			// Springt in der History um einen Eintrag zurück.
			//
			function HistoryBack()
			{
				if(g_historyIndex > 0)
				{
					g_historyIndex--;
					FillParametersIntoForm(g_history[g_historyIndex]);
				}
			}

			//
			// Springt in der History um einen Eintrag vorwärts.
			//
			function HistoryForward()
			{
				if(g_historyIndex < g_history.length - 1)
				{
					g_historyIndex++;
					FillParametersIntoForm(g_history[g_historyIndex]);
				}
			}

			//
			// Gibt ein Duplikat (keine Referenz!) des Parameter-Objekts zurück
			//
			function CloneParameters(parSource)
			{
				var parClone = parSource.constructor();
				CopyParameters(parClone, parSource);
				return parClone;
			}

			//
			// Kopiert den Inhalt eines Parameter-Objekts
			//
			function CopyParameters(parDest, parSource)
			{
				for (var key in parSource)
				{
					if(parSource[key].constructor === Array)
					{
						parDest[key] = parSource[key].slice();
						for (var i = 0, l = parSource[key].length; i < l; i++)
							parDest[key][i] = parSource[key][i];
					}
					else parDest[key] = parSource[key];
				}
			}

			//
			// Vergleicht zwei Parameter-Objekte
			//
			function EqualParameters(parDest, parSource)
			{
				for (var key in parSource)
				{
					if(parSource[key].constructor === Array)
					{
						for (var i = 0, l = parSource[key].length; i < l; i++)
							if(parDest[key][i] !== parSource[key][i]) return false;
					}
					else if(parDest[key] !== parSource[key]) return false;
				}
				return true;
			}

			  ////////////////////////
			 // Formularverwaltung //
			////////////////////////

			//
			// Zeigt die Parameter im Formular an
			//
			function FillParametersIntoForm(a_par, a_reMin, a_reMax, a_imMin, a_imMax, a_itMax, a_escRadius, a_smoothing, a_imgWidth, a_imgHeight, a_pxInterpolation, a_colorMode, a_colors, a_linearity, a_linRange, a_colorCount, a_colorCompress, a_colorInvert, a_repCount, a_cyclePalette, a_reduceHalo, a_colorImax)
			{
				$('reMin').value = a_par ? a_par.reMin : a_reMin !== undefined ? a_reMin : g_par.reMin;
				$('reMax').value = a_par ? a_par.reMax : a_reMax !== undefined ? a_reMax : g_par.reMax;
				$('imMin').value = a_par ? a_par.imMin : a_imMin !== undefined ? a_imMin : g_par.imMin;
				$('imMax').value = a_par ? a_par.imMax : a_imMax !== undefined ? a_imMax : g_par.imMax;
				$('itMax').value = a_par ? a_par.itMax : a_itMax !== undefined ? a_itMax : g_par.itMax;
				$('escRadius').value = a_par ? a_par.escRadius : a_escRadius !== undefined ? a_escRadius : g_par.escRadius;
				$('smoothing').checked = a_par ? a_par.smoothing : a_smoothing !== undefined ? a_smoothing : g_par.smoothing;
				$('imgWidth').value = a_par ? a_par.imgWidth : a_imgWidth !== undefined ? a_imgWidth : g_par.imgWidth;
				$('imgHeight').value = a_par ? a_par.imgHeight : a_imgHeight !== undefined ? a_imgHeight : g_par.imgHeight;
				$('pxInterpolation').value = a_par ? a_par.pxInterpolation : a_pxInterpolation !== undefined ? a_pxInterpolation : g_par.pxInterpolation;
				$('colorMode').value = a_par ? a_par.colorMode : a_colorMode !== undefined ? a_colorMode : g_par.colorMode;
				for (var i = 0; i < g_nColorsAvailable; i++) $('color' + (i + 1)).value = NumberToHexColor(a_par ? a_par.colors[i] : a_colors !== undefined && a_colors[i] !== undefined ? a_colors[i] : g_par.colors[i]);
				$('linearity').value = a_par ? a_par.linearity : a_linearity !== undefined ? a_linearity : g_par.linearity;
				$('linRange').value = a_par ? a_par.linRange : a_linRange !== undefined ? a_linRange : g_par.linRange;
				$('colorCount').value = a_par ? a_par.colorCount : a_colorCount !== undefined ? a_colorCount : g_par.colorCount;
				$('colorCompress').checked = a_par ? a_par.colorCompress : a_colorCompress !== undefined ? a_colorCompress : g_par.colorCompress;
				$('colorInvert').checked = a_par ? a_par.colorInvert : a_colorInvert !== undefined ? a_colorInvert : g_par.colorInvert;
				$('repCount').value = a_par ? a_par.repCount : a_repCount !== undefined ? a_repCount : g_par.repCount;
				$('cyclePalette').checked = a_par ? a_par.cyclePalette : a_cyclePalette !== undefined ? a_cyclePalette : g_par.cyclePalette;
				$('reduceHalo').checked = a_par ? a_par.reduceHalo : a_reduceHalo !== undefined ? a_reduceHalo : g_par.reduceHalo;
				$('colorImax').value = NumberToHexColor(a_par ? a_par.colorImax : a_colorImax !== undefined ? a_colorImax : g_par.colorImax);

				EnableControls();
			}

			//
			// Liest die Formular-Parameter aus
			//
			function ReadParametersFromForm()
			{
				g_par.reMin = parseFloat($('reMin').value);
				g_par.reMax = parseFloat($('reMax').value);
				g_par.imMin = parseFloat($('imMin').value);
				g_par.imMax = parseFloat($('imMax').value);
				g_par.itMax = parseInt($('itMax').value, 10);
				g_par.escRadius = parseInt($('escRadius').value, 10);
				g_par.smoothing = $('smoothing').checked;
				g_par.imgWidth = parseInt($('imgWidth').value, 10);
				g_par.imgHeight = parseInt($('imgHeight').value, 10);
				g_par.pxInterpolation = parseInt($('pxInterpolation').value, 10);
				g_par.colorMode = $('colorMode').value;
				for (var i = 0; i < g_nColorsAvailable; i++) g_par.colors[i] = HexColorToNumber($('color' + (i + 1)).value);
				g_par.linearity = parseInt($('linearity').value, 10);
				g_par.linRange = parseInt($('linRange').value, 10);
				g_par.colorCount = parseInt($('colorCount').value, 10);
				g_par.colorCompress = $('colorCompress').checked;
				g_par.colorInvert = $('colorInvert').checked;
				g_par.repCount = parseInt($('repCount').value, 10);
				g_par.cyclePalette = $('cyclePalette').checked;
				g_par.reduceHalo = $('reduceHalo').checked;
				g_par.colorImax = HexColorToNumber($('colorImax').value);
			}

			//
			// Aktiviert/deaktiviert die Steuerelemente abhängig vom gewählten Farbmodus
			//
			function EnableControls()
			{
				// Alle Controls außer den Zeichnen-Button während des Zeichnens deaktivieren
				var form = $('form');
				for (var i = 0, l = form.children.length; i < l; i++)
				{
					var tagName = form.children[i].tagName;
					var id = form.children[i].id;
					if((tagName == 'INPUT' || tagName == 'SELECT') && id != 'linearity' && id != 'linRange' && id != 'drawButton')
					{
						form.children[i].disabled = g_bDrawing;
					}
				}
				if(g_bDrawing) return;

				$('historyBack').disabled = !(g_historyIndex > 0);
				$('historyForward').disabled = !(g_historyIndex < g_history.length - 1);

				var colorMode = $('colorMode').value;
				var linearity = parseInt($('linearity').value, 10);
				var colorCount = parseInt($('colorCount').value, 10);
				var repCount = parseInt($('repCount').value, 10);

				if(colorCount === 1) $('colorCount').value = colorCount = 2; // colorCount darf nicht 1 sein!
				if(repCount < 1) $('repCount').value = repCount = 1; // repCount muss mindestens 1 sein!

				var gradientNo = colorMode.substr(0, 8) === 'gradient' ? +colorMode.substr(-1) : 0;
				for (var i = 1; i <= g_nColorsAvailable; i++) $('color' + i).disabled = !(i <= gradientNo), $('color' + i).style.outlineColor = (i <= gradientNo) ? '#000000' : '#C0C0C0' ;

				$('linearity').disabled = !('gradient' === colorMode.substr(0, 8));
				$('linRange').disabled = !('gradient' === colorMode.substr(0, 8));
				$('colorCount').disabled = !('gradient' === colorMode.substr(0, 8) && linearity !== 3);
				$('colorCompress').disabled = !('gradient' === colorMode.substr(0, 8) && linearity !== 3);
				$('colorInvert').disabled = !('gradient' === colorMode.substr(0, 8));
				$('repCount').disabled = !('gradient' === colorMode.substr(0, 8));
				$('cyclePalette').disabled = !('gradient' === colorMode.substr(0, 8) && repCount > 1);
				$('reduceHalo').disabled = !('gradient' === colorMode.substr(0, 8));

				$('reMin').style.backgroundColor = g_sel.mode > 0 ? 'yellow' : '';
				$('reMax').style.backgroundColor = g_sel.mode > 1 ? 'yellow' : '';
				$('imMin').style.backgroundColor = g_sel.mode > 0 ? 'yellow' : '';
				$('imMax').style.backgroundColor = g_sel.mode > 1 ? 'yellow' : '';

				// Ausgabefelder aktualisieren
				var linRange = parseFloat($('linRange').value) / 10;
				$('linRangeOut').value = linRange.toFixed(2);
			}

			//
			// Ausgabe der Berechnungsdauer
			//
			function DisplayRenderingTime()
			{
				var dtDuration = (new Date() - g_dtSTart) / 1000;
				$('duration').innerHTML = 't=' + dtDuration + 's';
			}

			//
			// Errechnung und Ausgabe des Vergrößerungsfaktors
			//
			function GetMagnification()
			{
				var reDiff = g_par.reMax - g_par.reMin;
				var imDiff = g_par.imMax - g_par.imMin;
				return 4 / (g_par.imgHeight < g_par.imgWidth ? imDiff : reDiff);
			}

			function DisplayMagnification()
			{
				var mag = GetMagnification();
				var exp = 0;
				if(mag < 1) while (mag < 1) mag *= 1000, exp -= 3;
				else while (mag >= 1000) mag /= 1000, exp += 3;
				$('magnification').innerHTML = g_strMagnification + '=' + mag.toPrecision(3) + '&times;10<sup>' + exp + '</sup>';
			}

			//
			// Tooltips setzen
			//
			function SetTooltips()
			{
				// Eingabefeld Imax
				$('itMax').title = 
					g_strMaxNumberOfIterations + '.\n' +
					g_strPresentInTheImageSurrounding + ': ' + g_minIt.toFixed(3) + ' ... ' + g_maxIt.toFixed(3) + '\n' +
					g_strMandelbrotSetPresent + ': ' + (g_itMaxReached ? g_strYes : g_strNo);
			}

			//
			// Umschaltung auf Linearität "Logarithmus", wenn Regler bewegt wird
			//
			function OnChangeRange()
			{
				var linearity = parseInt($('linearity').value, 10);
				if(linearity !== 4 && linearity !== 5 && linearity !== 6) $('linearity').value = 4;
			}

			  /////////////////////////////////////
			 // Anpassung der Fraktal-Parameter //
			/////////////////////////////////////

			//
			// Vergrößert/verkleinert die Grafik um einen Faktor (Zoom-Funktion)
			//
			function Zoom(zoomIn)
			{
				ReadParametersFromForm();

				var zoomFactor = parseFloat($('zoomFactor').value, 10);
				if(zoomIn) zoomFactor = 1 / zoomFactor;
				zoomFactor /= 2;

				var reDelta = g_par.reMax - g_par.reMin;
				var imDelta = g_par.imMax - g_par.imMin;

				var reCenter = g_par.reMin + reDelta / 2;
				var imCenter = g_par.imMin + imDelta / 2;

				FillParametersIntoForm(undefined, reCenter - reDelta * zoomFactor, reCenter + reDelta * zoomFactor, imCenter - imDelta * zoomFactor, imCenter + imDelta * zoomFactor);
				Draw();
			}

			//
			// Verschiebt die Grafik um einen Prozentwert relativ zum Bildausschnitt.
			//
			function Move(direction)
			{
				ReadParametersFromForm();

				var moveFactor = parseInt($('movePercent').value, 10) / 100;

				var reDelta = (g_par.reMax - g_par.reMin) * moveFactor;
				var imDelta = (g_par.imMax - g_par.imMin) * moveFactor;

				switch(direction)
				{
					case 'L': g_par.reMin -= reDelta; g_par.reMax -= reDelta; break;
					case 'R': g_par.reMin += reDelta; g_par.reMax += reDelta; break;
					case 'U': g_par.imMin += imDelta; g_par.imMax += imDelta; break;
					case 'D': g_par.imMin -= imDelta; g_par.imMax -= imDelta; break;
				}

				FillParametersIntoForm();
				Draw();
			}

			//
			// Die Min-/Max-Werte von Real- und Imaginärteil so anpassen, dass die
			// Grafik bildfüllend wird, ohne das Seitenverhältnis zu verändern:
			//
			function AdjustValues()
			{
				var imgAspectRatio = g_par.imgWidth / g_par.imgHeight;
				var objAspectRatio = (g_par.reMax - g_par.reMin) / (g_par.imMax - g_par.imMin);

				if(imgAspectRatio > objAspectRatio)
				{
					var delta = ((g_par.imMax - g_par.imMin) * imgAspectRatio - (g_par.reMax - g_par.reMin)) / 2;
					g_par.reMin -= delta;
					g_par.reMax += delta;
				}
				else if(objAspectRatio > imgAspectRatio)
				{
					var delta = ((g_par.reMax - g_par.reMin) / imgAspectRatio - (g_par.imMax - g_par.imMin)) / 2;
					g_par.imMin -= delta;
					g_par.imMax += delta;
				}
			}

			  ////////////////////////////////
			 // Zeichnen der Fraktalgrafik //
			////////////////////////////////

			var g_imgData, g_rgbaArray, g_rgbaIndex, g_y = 0;   // Bild
			var g_bGradient, g_bRandom;   // Farbmodus (Palette)
			var g_imaxRed, g_imaxGreen, g_imaxBlue;   // Farbe für Iterationsgrenze
			var g_rgbValues = [], g_rgbDiffs = [], g_nGradients = 0;   // Palette "Farbverlauf"
			var g_palRed = [], g_palGreen = [], g_palBlue = [];   // Farbpalette
			var g_red, g_green, g_blue;   // Farben für ein Pixel
			var g_reStep, g_imStep;   // Schrittweite für Real- und Imaginärzahl
			var g_escRadius2;   // Quadrat des "Fluchtradius"
			var g_itCache;   // Puffer für die errechneten Iterationen
			var g_minIt, g_maxIt;   // Iterator-Wertebereich
			var g_itMaxReached; // true, wenn itMax im Bild erreicht wurde; false, wenn nicht
			var g_itDelta, g_itDeltaChanged;   // Merkvariablen für geänderten Iterator-Wertebereich
			var g_bRedraw;   // Fraktaldaten nicht neu berechnen, sondern aus g_itCache lesen.
			var g_dtSTart;   // Startzeit zur Berechnung der Ausführungsdauer
			var g_bStopRequest;   // Stop-Anfordernung
			var g_linRange, g_linRangeInverse;   // // Konstante für Linearität "log", "gam" und "tanh"
			var g_piHalf = Math.PI / 2;   // Konstante für Linearität "Sinus"
			var g_logMultiplier, g_logDivisor;   // Konstanten für Linearität "Logarithmus"

			//
			// Mandelbrot-Iteration für einen Bildpunkt (x,y).
			// Errechnet aus Real- und Imaginärteil die Anzahl der Iterationen
			// bis zur Divergenz (Radius = 2) oder bis zum Erreichen von itMax.
			// Die Iterationsvorshrift Z->Z²+C wurde dazu für reelle Zahlen transformiert.
			//
			var g_constLog2 = Math.log(2);
			function Iterate(x, y)
			{
				var a = 0, b = 0;     // Real- und Imaginärteil von Z (Startwert: Z=0)
				var a2 = 0, b2 = 0;   // Quadrat von a und b merken (Performance!)
				var it = 0;           // Iterationszähler

				while (it < g_par.itMax && a2 + b2 < g_escRadius2)   // |Z| < 2  =>  |Z|² = a²+b² < 2²
				{
					b = 2 * a * b + y;  // Komponenten des Imaginärteils berechnen
					a = a2 - b2 + x;    // Komponenten des Realteils berechnen

					a2 = a * a;         // Quadrate von Real- und Imaginärteil merken,
					b2 = b * b;         // um sie nicht zweimal berechnen zu müssen (Performance!)

					it++;
				}

				if(g_par.smoothing === true) it += 2 - Math.log(Math.log(a2 + b2)) / g_constLog2;
				return it;
			}

			//
			// Ermittelt, ob die Grafik nur neugezeichnet werden kann oder neu berechnet werden muss.
			// Wenn sich im Formular nur die Parameter zur Farbdarstellung geändert haben, ist keine Neuberechnung nötig.
			//
			function CanRedraw()
			{
				if(g_par.reMin !== parseFloat($('reMin').value)) return false;
				if(g_par.reMax !== parseFloat($('reMax').value)) return false;
				if(g_par.imMin !== parseFloat($('imMin').value)) return false;
				if(g_par.imMax !== parseFloat($('imMax').value)) return false;
				if(g_par.itMax !== parseInt($('itMax').value, 10)) return false;
				if(g_par.escRadius !== parseInt($('escRadius').value, 10)) return false;
				if(g_par.smoothing !== $('smoothing').checked) return false;
				if(g_par.imgWidth !== parseInt($('imgWidth').value, 10)) return false;
				if(g_par.imgHeight !== parseInt($('imgHeight').value, 10)) return false;
				if(g_par.pxInterpolation !== parseInt($('pxInterpolation').value, 10)) return false;

				if(g_y < g_par.imgHeight) return false; // Bild vollständig gezeichnet oder abgebrochen?

				return true;
			}

			//
			// OnClicked-Handler für den Button "Zeichnen"
			//
			function OnButtonClickedDraw()
			{
				if(g_bDrawing)
					g_bStopRequest = true;
				else
					Draw(CanRedraw());
			}

			//
			// Neuzeichnen des Bildes ohne Neuberechnung und ohne History-Eintrag
			//
			function Paint()
			{
				if(!g_bDrawing) Draw(true, true);
			}

			//
			// Hauptroutine zum Zeichnen der Grafik
			// (wird von verschiedenen Stellen aus aufgerufen)
			//
			function Draw(bRedraw, bNoHistoryAdd)
			{
				g_bRedraw = (bRedraw === true);

				g_sel.reset();
				ReadParametersFromForm();
				SetCanvas();
				AdjustValues();
				FillParametersIntoForm();
				$('example').value = '--';

				if(!g_bRedraw)
				{
					// Ein eindimensionales Array würde zwar theoretisch auch gehen und wäre programmtechnisch einfacher gewesen,
					// ist aber für JavaSCript wohl zu groß (>1 Mio. Elemente) und bringt Fehler, wenn es "zu schnell" gefüllt wird.

					g_itCache = Array(g_par.imgHeight * g_par.pxInterpolation);
					for (var y = 0; y < g_par.imgHeight * g_par.pxInterpolation; y++) g_itCache[y] = Array(g_par.imgWidth * g_par.pxInterpolation);

					// Iterator-Wertebereich initialisieren
					g_minIt = 1E20, g_maxIt = 0;
					g_itMaxReached = false;
					g_itDelta = -1, g_itDeltaChanged = false;
				}

				if(!bNoHistoryAdd) HistoryAdd();
				PrepareColorPalette();
				DrawImage();
			}

			//
			// Startet den Zeichenvorgang
			//
			function DrawImage()
			{
				g_reStep = (g_par.reMax - g_par.reMin) / g_par.imgWidth / g_par.pxInterpolation;
				g_imStep = (g_par.imMax - g_par.imMin) / g_par.imgHeight / g_par.pxInterpolation;
				g_escRadius2 = g_par.escRadius * g_par.escRadius;

				g_imgData = g_imgContext.getImageData(0, 0, g_imgElement.width, g_imgElement.height);
				g_rgbaArray = g_imgData.data;

				// Formular aktualisieren
				g_bDrawing = true;
				$('drawButton').value = g_strStop;
				EnableControls();

				// Startzeit zur Berechnung der Ausführungsdauer merken
				g_dtSTart = new Date();

				if(!g_bRedraw) PaleCanvas(g_imgData);

				// Teilstücke zeichnen
				g_bStopRequest = false;
				g_rgbaIndex = 0, g_y = 0;
				Schedule(DrawLines);
			}

			//
			// Callback-Funktion für Schedule():
			// Zeichnet einen Bereich von Zeilen ab Zeile g_y für eine maximale Zeitdauer.
			//
			function DrawLines()
			{
				// Startzeit merken
				var msBetweenUpdates = 1000; // maximale Zeitdauer, für die gezeichnet wird
				var dtSTart = new Date(); // Startzeit

				var it, yStart = g_y;

				if(g_bRedraw)
				{
					yStart = 0;
					g_y = g_par.imgHeight;
				}
				else
				{
					// Bildzeilen berechnen
					do
					{
						for (var x = 0; x < g_par.imgWidth; x++)
						{
							for (var yy = 0; yy < g_par.pxInterpolation; yy++)
							{
								var yyy = g_y * g_par.pxInterpolation + yy;
								var im = g_par.imMax - yyy * g_imStep;

								for (var xx = 0; xx < g_par.pxInterpolation; xx++)
								{
									var xxx = x * g_par.pxInterpolation + xx;
									var re = g_par.reMin + xxx * g_reStep;

									g_itCache[yyy][xxx] = it = Iterate(re, im);

									if(it < g_par.itMax)
									{ 
										g_minIt = Math.min(g_minIt, it);
										g_maxIt = Math.max(g_maxIt, it);
									}
									else
									{
										g_itMaxReached = true;
									}
								}
							}
						}
						g_y++;
					}
					while (!g_bStopRequest && g_y < g_par.imgHeight && new Date() - dtSTart < msBetweenUpdates);

					// Iterator-Wertebereich aktualisieren
					if(g_itDelta === -1) g_itDelta = g_maxIt - g_minIt
					else if(g_itDelta !== g_maxIt - g_minIt) g_itDeltaChanged = true;
				}

				// Falls Wertebereich geändert, von Beginn an zeichnen
				if((g_par.colorCompress || g_par.linearity === 3) && g_y === g_par.imgHeight && g_itDeltaChanged)
				{
					g_rgbaIndex = 0;
					yStart = 0;
				}

				// Farben für berechnete Zeilen ermitteln
				for (var y = yStart; y < g_y; y++)
				{
					// Zeile berechnen
					for (var x = 0; x < g_par.imgWidth; x++)
					{
						// Farben initialisieren für Interpolation
						g_red = 0, g_green = 0, g_blue = 0;

						// Pixel berechnen
						var pxCount = 0;
						for (var yy = 0; yy < g_par.pxInterpolation; yy++)
						{
							var yyy = y * g_par.pxInterpolation + yy;

							for (var xx = 0; xx < g_par.pxInterpolation; xx++)
							{
								pxCount++;

								var xxx = x * g_par.pxInterpolation + xx;

								it = g_itCache[yyy][xxx];
								CalculateColor(it);
							}
						}

						// Pixel interpolieren
						g_red = ~~(g_red / pxCount);
						g_green = ~~(g_green / pxCount);
						g_blue = ~~(g_blue / pxCount);

						// Pixel setzen
						g_rgbaArray[g_rgbaIndex++] = g_red;
						g_rgbaArray[g_rgbaIndex++] = g_green;
						g_rgbaArray[g_rgbaIndex++] = g_blue;
						g_rgbaArray[g_rgbaIndex++] = 255;
					}
				}

				// Berechnete Zeilen ausgeben
				g_imgContext.putImageData(g_imgData, 0, 0, 0, yStart, g_imgElement.width, g_y - yStart);

				// Anzeige von Informationen aktualisieren
				DisplayRenderingTime();
				DisplayMagnification();
				SetTooltips();

				// Nächste Zeile ausgeben
				if (!g_bStopRequest && g_y < g_par.imgHeight)
				{
					Schedule(DrawLines);
				}
				else
				{
					EndDrawImage()
				}
			}

			function EndDrawImage()
			{
				// Aufräumen
				g_rgbValues.length = 0;
				g_rgbDiffs.length = 0;
				g_palRed.length = 0;
				g_palGreen.length = 0;
				g_palBlue.length = 0;

				// Formular aktualisieren
				g_bDrawing = false;
				$('drawButton').value = g_strDraw;
				EnableControls();
			}

			//
			// Asynchroner Aufruf der Zeichen-Funktion DrawLines()
			//
			function Schedule(callbackFunction)
			{
				if(typeof window.requestAnimationFrame === 'function')
					window.requestAnimationFrame(callbackFunction)
				else
					window.setTimeout(callbackFunction, 0);
			}

			//
			// Bild "blass" machen (statt ganz zu löschen vor dem Zeichnen)
			//
			function PaleCanvas()
			{
				var imgData = g_imgContext.getImageData(0, 0, g_imgElement.width, g_imgElement.height);
				var rgbaArray = imgData.data;

				for (var y = 0, i = 0; y < g_imgElement.height; y++)
				{
					for (var x = 0; x < g_imgElement.width; x++, i += 4)
					{
						rgbaArray[i + 3] = 64; // set alpha to 0.25
					}
				}

				g_imgContext.putImageData(imgData, 0, 0);
			}

			//
			// Farbpaletten vorbereiten.
			// Diese Funktion muss einmalig vor einem Zeichenvorgang aufgerufen werden.
			//
			function PrepareColorPalette()
			{
				// Farbmodus (Palette)
				g_bGradient = ('gradient' === g_par.colorMode.substr(0, 8));
				g_bRandom = ('random' === g_par.colorMode);

				// Farbe für Iterationsgrenze
				g_imaxRed = (g_par.colorImax >> 16) & 0xFF;
				g_imaxGreen = (g_par.colorImax >> 8) & 0xFF;
				g_imaxBlue = g_par.colorImax & 0xFF;

				// Palette "Farbverlauf"
				if(g_bGradient)
				{
					g_nGradients = 0;
					g_linRange = g_par.linRange / 10;
					g_linRangeInverse = 1 / Math.max(g_linRange, 0.001);
					g_logMultiplier = Math.pow(4, g_linRange);
					g_logDivisor = Math.log(g_logMultiplier + 1);

					var nCol = parseInt(g_par.colorMode.substr(-1), 10); // Anzahl Farben, die ausgewählt wurden
					g_nGradients = nCol - 1; // Anzahl Teil-Farbverläufe (oder "Subpaletten")

					for (var i = 0; i < g_nColorsAvailable; i++)
					{
						g_rgbValues[i] = new Array(3);
						g_rgbDiffs[i] = new Array(3);
					}

					for (var bgr = 0; bgr < 3; bgr++)
					{
						for (var i = 0; i < g_nColorsAvailable; i++)
							g_rgbValues[i][2 - bgr] = (g_par.colors[i] >> (bgr * 8)) & 0xFF;

						for (var i = 0; i < g_nColorsAvailable; i++)
							g_rgbDiffs[i][2 - bgr] = g_rgbValues[(i + 1) % g_nColorsAvailable][2 - bgr] - g_rgbValues[i][2 - bgr];
					}
				}

				// Palette "Zufall"
				if(g_bRandom)
				{
					for (var i = 0; i < g_par.itMax; i++)
					{
						g_palRed[i] = ~~(Math.random() * 256);
						g_palGreen[i] = ~~(Math.random() * 256);
						g_palBlue[i] = ~~(Math.random() * 256);
					}
				}

			}

			//
			// Berechnet die Farbe für den angegebenen Iterator-Wert it.
			// Zuvor muss einmalig pro Zeichenvorgang PrepareColorPalette()
			// zur Vorbereitung der Farbpaletten aufgerufen worden sein.
			//
			function CalculateColor(it)
			{
				if(it < g_par.itMax)
				{
					if(g_bGradient)
					{
						var itDelta = g_par.itMax - 1;
						var itIndex = it - 1;

						if(g_par.colorCompress)
						{
							itDelta = g_maxIt - g_minIt;
							itIndex = it - g_minIt;
						}

						var iColor = 0.5;   // Normierter Farbindex [0...1]; bei nur 1 Farbe im Bild = Mitte (0.5)
						if(itDelta > 1)   // Mehr als 1 Farbe im Bild: Farbindex berechnen
						{
							if(g_par.colorCount > 1) itIndex = (~~(itIndex) % g_par.colorCount) * (itDelta - 1) / (g_par.colorCount - 1);

							iColor = itIndex / itDelta;

							// Linearität
							if(g_par.linearity === 3)      iColor = (Math.log(it) - Math.log(g_minIt)) / (Math.log(g_maxIt) - Math.log(g_minIt));   // adaptiv-logarithmisch
							else {
							if(g_par.linearity === 2)      iColor = Math.sin(iColor * g_piHalf);   // 1/4-sinusförmig
							else if(g_par.linearity === 4) iColor = Math.log(iColor * g_logMultiplier + 1) / g_logDivisor;   // logarithmisch
							else if(g_par.linearity === 5) iColor = Math.pow(iColor, g_linRangeInverse);   // Gamma
							else if(g_par.linearity === 6) iColor = Math.tanh(iColor * g_linRange) / Math.tanh(g_linRange); }   // Tangens Hyperbolicus

							var i = iColor;

							if(g_par.repCount > 1)   iColor = (iColor * g_par.repCount) % 1;
							if(g_par.cyclePalette && ~~(i * g_par.repCount) % 2) 
							                         iColor = 1 - iColor;
							if(g_par.colorInvert)    iColor = 1 - iColor;

						}

						iColor *= g_nGradients;   // Farbindex mit Anzahl Farbverläufen multiplizieren
						var iGradient = ~~iColor;   // Farbverlauf auswählen: 0 = Farbe 1-2, 1 = Farbe 2-3
						iColor -= iGradient;   // Farbindex auf Farbverlauf setzen

						// Sinusförmige statt lineare Interpolation des Farbmappings:
						// (siehe http://www.stefanbion.de/fraktal-generator/colormapping/index.htm, Abschnitt "Palette Interpolation")
						if(g_par.reduceHalo)
						{
							iColor = (Math.cos(iColor * Math.PI + Math.PI) + 1) / 2;
							//iColor = (Math.sin(iColor * Math.PI - Math.PI / 2) + 1) / 2;
						}

						g_red   += g_rgbValues[iGradient][0] + iColor * g_rgbDiffs[iGradient][0];
						g_green += g_rgbValues[iGradient][1] + iColor * g_rgbDiffs[iGradient][1];
						g_blue  += g_rgbValues[iGradient][2] + iColor * g_rgbDiffs[iGradient][2];
					}
					else if(g_bRandom)
					{
						it = ~~it;
						g_red   += g_palRed[it];
						g_green += g_palGreen[it];
						g_blue  += g_palBlue[it];
					}
				}
				else
				{
					// Farbe für Iterationsgrenze
					g_red   += g_imaxRed;
					g_green += g_imaxGreen;
					g_blue  += g_imaxBlue;
				}
			}

			  ////////////////////////////////////////
			 // Ausschnittsmarkierung mit der Maus //
			////////////////////////////////////////

			// Datenobjekt
			var g_sel =
			{
				reset: function() { if(this.selExists()) DrawSelection(0); this.mode = 0, this.mouseStartX = 0, this.mouseStartY = 0, this.mouseEndX = 0, this.mouseEndY = 0, this.selStartX = 0, this.selStartY = 0, this.selEndX = 0, this.selEndY = 0; },
				mouseMoved: function() { return (this.mouseStartX !== this.mouseEndX && this.mouseStartY !== this.mouseEndY); },
				selExists: function() { return (this.selStartX !== this.selEndX && this.selStartY !== this.selEndY); },

				mode: 0, // 0 = none, 1 = start, 2 = end
				mouseStartX: 0, mouseStartY: 0, mouseEndX: 0, mouseEndY: 0,
				selStartX: 0, selStartY: 0, selEndX: 0, selEndY: 0
			};

			function OnMouseDown(event)
			{
				if(g_bDrawing) return; // Nicht während des Zeichnens
				if(event.button !== 0) return; // Nur die linke Maustaste behandeln

				g_sel.mode = 1; // start selection

				// Koordinaten des Mauszeigers ermitteln
				g_sel.mouseStartX = g_sel.mouseEndX = event.offsetX;
				g_sel.mouseStartY = g_sel.mouseEndY = event.offsetY;
			}

			function OnMouseUp(event)
			{
				if(g_bDrawing) return; // Nicht während des Zeichnens
				if(event.button !== 0) return; // Nur die linke Maustaste behandeln
				if(g_sel.mode == 0) return; // Nur behandeln, wenn Selektionsmodus aktiv

				if(g_sel.mouseMoved())
				{
					g_sel.mode = 2; // end selection

					$('reMin').value = g_par.reMin + g_sel.selStartX * (g_par.reMax - g_par.reMin) / g_par.imgWidth;
					$('imMin').value = g_par.imMax - g_sel.selEndY * (g_par.imMax - g_par.imMin) / g_par.imgHeight;
					$('reMax').value = g_par.reMin + g_sel.selEndX * (g_par.reMax - g_par.reMin) / g_par.imgWidth;
					$('imMax').value = g_par.imMax - g_sel.selStartY * (g_par.imMax - g_par.imMin) / g_par.imgHeight;

					EnableControls();
				}
				else
				{
					g_sel.mode = 0; // no selection

					FillParametersIntoForm(); // Originalwerte (aus den globalen Variablen) wiederherstellen
					UpdateSelection(); // Auswahl-Rechteck entfernen
				}
			}

			function OnMouseMove(event)
			{
				if(g_bDrawing) return; // Nicht während des Zeichnens
				if(g_sel.mode != 1) return; // Nur behandeln, wenn Selektionsmodus gestartet (= linke Maustaste wurde gedrückt)

				// Koordinaten des Mauszeigers ermitteln
				g_sel.mouseEndX = event.offsetX;
				g_sel.mouseEndY = event.offsetY;

				UpdateSelection(event.ctrlKey); // Auswahl-Rechteck zeichnen/aktualisieren
			}

			//
			// Auswahlrahmen aktualisieren
			//
			function UpdateSelection(bFromCenter)
			{
				// Auswahlrahmen entfernen, falls vorhanden:
				if(g_sel.selExists()) DrawSelection(0);

				// Auswahlrahmen zeichnen, falls die Maus bewegt wurde und die linke Maustaste gedrückt ist:
				if(g_sel.mouseMoved() && g_sel.mode == 1) DrawSelection(1, bFromCenter);
			}

			//
			// Ausschnittsmarkierung zeichnen
			//
			function DrawSelection(mode, bFromCenter)
			{
				var drawStartX, drawStartY, drawEndX, drawEndY;

				if(mode)
				{
					// Modus: Auswahlrahmen zeichnen
					if(g_sel.mouseStartX < g_sel.mouseEndX) drawStartX = bFromCenter ? g_sel.mouseStartX - (g_sel.mouseEndX - g_sel.mouseStartX) : g_sel.mouseStartX, drawEndX = g_sel.mouseEndX;
					else                                    drawStartX = g_sel.mouseEndX, drawEndX = bFromCenter ? g_sel.mouseStartX - (g_sel.mouseEndX - g_sel.mouseStartX) : g_sel.mouseStartX;

					if(g_sel.mouseStartY < g_sel.mouseEndY) drawStartY = bFromCenter ? g_sel.mouseStartY - (g_sel.mouseEndY - g_sel.mouseStartY) : g_sel.mouseStartY, drawEndY = g_sel.mouseEndY;
					else                                    drawStartY = g_sel.mouseEndY, drawEndY = bFromCenter ? g_sel.mouseStartY - (g_sel.mouseEndY - g_sel.mouseStartY) : g_sel.mouseStartY;

					g_sel.selStartX = drawStartX, g_sel.selStartY = drawStartY, g_sel.selEndX = drawEndX, g_sel.selEndY = drawEndY;
				}
				else
				{
					// Modus: Auswahlrahmen entfernen
					drawStartX = g_sel.selStartX, drawStartY = g_sel.selStartY, drawEndX = g_sel.selEndX, drawEndY = g_sel.selEndY;
					g_sel.selStartX = 0, g_sel.selStartY = 0, g_sel.selEndX = 0, g_sel.selEndY = 0;
				}

				var imgData = g_imgContext.getImageData(0, 0, g_imgElement.width, g_imgElement.height);
				var rgbaArray = imgData.data;

				for (var y = 0, i = 0; y < g_imgElement.height; y++)
				{
					for (var x = 0; x < g_imgElement.width; x++, i += 4)
					{
						// skip inside
						if(x > drawStartX && x < drawEndX && y > drawStartY && y < drawEndY)
							continue;

						// draw frame
						if(x >= drawStartX && x <= drawEndX && y >= drawStartY && y <= drawEndY)
							rgbaArray[i] ^= 255, rgbaArray[i + 1] ^= 255, rgbaArray[i + 2] ^= 255; // invert color

						// draw outside
//						if(x < drawStartX || x > drawEndX || y < drawStartY || y > drawEndY)
//							rgbaArray[i + 3] ^= 191; // set alpha to 0.25 or back
// Deaktiviert, weil nach Entfernen Streifen sichtbar bleiben.
					}
				}

				g_imgContext.putImageData(imgData, 0, 0);
			}

			  /////////////////////////////
			 // Daten-Ein- und -Ausgabe //
			/////////////////////////////

			//
			// Grafik als PNG-Datei herunterladen
			//
			function SavePng()
			{
				var png = image.toDataURL('image/png').replace('image/png', 'image/octet-stream');
//				window.location.href = png;
				window.open(png, '_self');
			}

			//
			// Parameter als Textdatei herunterladen
			//
			function SaveTxt()
			{
				var text =
					'# Parameter file for the Mandelbrot set\n' +
					'# ' + CreateLink() + '\n' +
					'\n' +
					'# Location\n' +
					'reMin=' + g_par.reMin + '\n' +
					'reMax=' + g_par.reMax + '\n' +
					'imMin=' + g_par.imMin + '\n' +
					'imMax=' + g_par.imMax + '\n' +
					'\n' +
					'# Location (alternative notation)\n' +
					'Real=' + ((g_par.reMin + g_par.reMax) / 2) + '\n' +
					'Imaginary=' + ((g_par.imMax + g_par.imMin) / 2) + '\n' +
					'Magnification=' + GetMagnification() + '\n' +
					'\n' +
					'# Fractal parameters\n' +
					'itMax=' + g_par.itMax + '\n' +
					'escRadius=' + g_par.escRadius + '\n' +
					'smoothing=' + g_par.smoothing + '\n' +
					'\n' +
					'# Image parameters\n' +
					'imgWidth=' + g_par.imgWidth + '\n' +
					'imgHeight=' + g_par.imgHeight + '\n' +
					'pxInterpolation=' + g_par.pxInterpolation + '\n' +
					'\n' +
					'# Color parameters\n' +
					'colorMode=' + g_par.colorMode + '\n';

				for (var i = 0; i < g_nColorsAvailable; i++)
					text += 'color' + (i + 1) + '=' + NumberToHexColor(g_par.colors[i]) + '\n';

				text +=
					'linearity=' + g_par.linearity + '\n' +
					'linRange=' + g_par.linRange + '\n' +
					'colorCount=' + g_par.colorCount + '\n' +
					'colorCompress=' + g_par.colorCompress + '\n' +
					'colorInvert=' + g_par.colorInvert + '\n' +
					'repCount=' + g_par.repCount + '\n' +
					'cyclePalette=' + g_par.cyclePalette + '\n' +
					'reduceHalo=' + g_par.reduceHalo + '\n' +
					'colorImax=' + NumberToHexColor(g_par.colorImax) + '\n';

				window.open('data:application/txt,' + encodeURIComponent(text), '_self');
			}

			//
			// Link mit Parametern erzeugen.
			//
			function DisplayLink()
			{
				var url = CreateLink();

				if(window.prompt(g_english ? 'Here\'s the link to the fractal image\n\n<Ctrl>+<C>: Copy to clipboard\n[OK]: Test the link (opens an new browser tab)\n[Cancel]: Close this window\n ' : 'Hier der Link zur Grafik\n\n<Strg>+<C>: In die Zwischenablage kopieren\n[OK]: Link testen (öffnet neues Browser-Tab)\n[Abbrechen]: Dieses Fenster schließen\n ', url))
					window.open(url, '_blank');
			}

			function CreateLink()
			{
				var url =
					location.protocol + '//' + location.host + location.pathname + '?' +
					'reMin=' + encodeURIComponent(g_par.reMin) + '&' +
					'reMax=' + encodeURIComponent(g_par.reMax) + '&' +
					'imMin=' + encodeURIComponent(g_par.imMin) + '&' +
					'imMax=' + encodeURIComponent(g_par.imMax) + '&' +
					'itMax=' + encodeURIComponent(g_par.itMax) + '&' +
					'escRadius=' + encodeURIComponent(g_par.escRadius) + '&' +
					'smoothing=' + encodeURIComponent(g_par.smoothing) + '&' +
					'imgWidth=' + encodeURIComponent(g_par.imgWidth) + '&' +
					'imgHeight=' + encodeURIComponent(g_par.imgHeight) + '&' +
					'pxInterpolation=' + encodeURIComponent(g_par.pxInterpolation) + '&' +
					'colorMode=' + encodeURIComponent(g_par.colorMode) + '&';

				for (var i = 0; i < g_nColorsAvailable; i++)
					url += 'color' + (i + 1) + '=' + encodeURIComponent(NumberToHexColor(g_par.colors[i])) + '&';

				url +=
					'linearity=' + encodeURIComponent(g_par.linearity) + '&' +
					'linRange=' + encodeURIComponent(g_par.linRange) + '&' +
					'colorCount=' + encodeURIComponent(g_par.colorCount) + '&' +
					'colorCompress=' + encodeURIComponent(g_par.colorCompress) + '&' +
					'colorInvert=' + encodeURIComponent(g_par.colorInvert) + '&' +
					'repCount=' + encodeURIComponent(g_par.repCount) + '&' +
					'cyclePalette=' + encodeURIComponent(g_par.cyclePalette) + '&' +
					'reduceHalo=' + encodeURIComponent(g_par.reduceHalo) + '&' +
					'colorImax=' + encodeURIComponent(NumberToHexColor(g_par.colorImax));

				return url;
			}

			//
			// Parameter aus Textdatei lesen
			//
			function OpenTxt(event)
			{
				var file = event.target.files[0];
				var reader = new FileReader();

				reader.onload = function()
				{
					ReadParametersFromTxt(reader.result);
				};

				reader.readAsText(file);
			}

			// Location in alternativer Notation
			var g_parReal, g_parImag, g_parMagn;
			var g_bCoordinatesSet, g_bLocationSet;

			//
			// Umrechnung Location (g_parReal, g_parImag, g_parMagn) in Bildausschnitt
			//
			function SetCoordinatesFromLocation(par)
			{
				var distance = 4 / g_parMagn;
				var korrReal = par.imgWidth > par.imgHeight ? par.imgWidth / par.imgHeight : 1;
				var korrImag = par.imgHeight > par.imgWidth ? par.imgHeight / par.imgWidth : 1;

				par.reMin = g_parReal - distance * korrReal / 2;
				par.reMax = g_parReal + distance * korrReal / 2;
				par.imMin = g_parImag - distance * korrImag / 2;
				par.imMax = g_parImag + distance * korrImag / 2;
			}

			//
			// Parst einen Parametertext (Text mit "name=wert"-Zeilen) und initialisiert die Variablen und die Controls damit
			//

			var g_parTemp = CloneParameters(g_par);

			function ReadParametersFromTxt(text)
			{
				g_bCoordinatesSet = g_bLocationSet = false;
				CopyParameters(g_parTemp, g_par); // Vorbelegung: aktuelle Parameter
				var lines = text.split('\n');
				for(var l = 0; l < lines.length; l++)
				{
					var line = lines[l].replace(/^\s+/, '').replace(/\s+$/, ''); // trim spaces
					if(line.substr(0, 1) === '#') continue; // Bemerkungszeile überspringen
					var pair = line.split("=");
					if(pair.length !== 2) continue; // Zeilen ohne Gleichheitszeichen überspringen
					var name = pair[0].replace(/^\s+/, '').replace(/\s+$/, ''); // trim spaces
					var value = pair[1].replace(/^\s+/, '').replace(/\s+$/, ''); // trim spaces

					if(!SetTempParameter(name, value, false))
					{
						alert('Fehler: Unbekannter Parameter "' + name + '" in Zeile ' + (l + 1) + '!');
						return;
					}
				}
				if(!g_bCoordinatesSet && g_bLocationSet)
					SetCoordinatesFromLocation(g_parTemp);
				FillParametersIntoForm(g_parTemp);
			}

			//
			// Parst die URL-Parameter und initialisiert die Variablen und die Controls damit
			//
			function ReadParametersFromUrl()
			{
				if(!location.search)
					return false;

				CopyParameters(g_parTemp, g_parDefault); // Vorbelegung: Default-Parameter
				var lines = location.search.substr(1).split('&');
				for(var l = 0; l < lines.length; l++)
				{
					var line = lines[l];
					var pair = line.split("=");
					if(pair.length === 1) pair[1] = 'true'; // Parameter ohne Value auf den Wert 'true' setzen
					var name = decodeURIComponent(pair[0]);
					var value = decodeURIComponent(pair[1]);

					if(!SetTempParameter(name, value, true))
					{
						alert('Fehler: Unbekannter ' + (l + 1) + '. Parameter "' + name + '"!');
						return false;
					}
				}
				FillParametersIntoForm(g_parTemp);
				return true;
			}

			//
			// Setzt den Parameter mit Namen 'name' auf den Wert 'value'
			//
			function SetTempParameter(name, value, bForce)
			{
				var bParAll = $('txtParametersAll').checked;
				var bParFractal = $('txtParFractal').checked;
				var bParFractalCoordOnly = $('txtParFractalCoordOnly').checked;
				var bParGraphic = $('txtParGraphic').checked;
				var bParGraphicColorsOnly = $('txtParGraphicColorsOnly').checked;

				var bSetCoord = bForce || bParAll || bParFractal || bParFractalCoordOnly;
				var bSetFrac = bForce || bParAll || (bParFractal && !bParFractalCoordOnly);
				var bSetColors = bForce || bParAll || bParGraphic || bParGraphicColorsOnly;
				var bSetGraph = bForce || bParAll || (bParGraphic && !bParGraphicColorsOnly)

				switch(name)
				{
					case 'reMin':			if(bSetCoord)	g_parTemp.reMin = parseFloat(value), g_bCoordinatesSet = true; break;
					case 'reMax':			if(bSetCoord)	g_parTemp.reMax = parseFloat(value), g_bCoordinatesSet = true; break;
					case 'imMin':			if(bSetCoord)	g_parTemp.imMin = parseFloat(value), g_bCoordinatesSet = true; break;
					case 'imMax':			if(bSetCoord)	g_parTemp.imMax = parseFloat(value), g_bCoordinatesSet = true; break;
					case 'itMax':			if(bSetFrac)	g_parTemp.itMax = parseInt(value, 10); break;
					case 'escRadius':		if(bSetFrac)	g_parTemp.escRadius = parseInt(value, 10); break;
					case 'smoothing':		if(bSetFrac)	g_parTemp.smoothing = (value === 'true'); break;
					case 'imgWidth':		if(bSetGraph)	g_parTemp.imgWidth = parseInt(value, 10); break;
					case 'imgHeight':		if(bSetGraph)	g_parTemp.imgHeight = parseInt(value, 10); break;
					case 'pxInterpolation':	if(bSetGraph)	g_parTemp.pxInterpolation = parseInt(value, 10); break;
					case 'colorMode':		if(bSetColors)	g_parTemp.colorMode = value; break;
					case 'linearity':		if(bSetGraph)	g_parTemp.linearity = parseInt(value, 10); break;
					case 'linRange':		if(bSetGraph)	g_parTemp.linRange = parseInt(value, 10); break;
					case 'colorCount':		if(bSetGraph)	g_parTemp.colorCount = parseInt(value, 10); break;
					case 'colorCompress':	if(bSetGraph)	g_parTemp.colorCompress = (value === 'true'); break;
					case 'colorInvert':		if(bSetGraph)	g_parTemp.colorInvert = (value === 'true'); break;
					case 'repCount':		if(bSetGraph)	g_parTemp.repCount = parseInt(value, 10); break;
					case 'cyclePalette':	if(bSetGraph)	g_parTemp.cyclePalette = (value === 'true'); break;
					case 'reduceHalo':		if(bSetGraph)	g_parTemp.reduceHalo = (value === 'true'); break;
					case 'colorImax':		if(bSetColors)	g_parTemp.colorImax = HexColorToNumber(value); break;
					case 'Real':			if(bSetCoord)	g_parReal = parseFloat(value), g_bLocationSet = true; break;
					case 'Imaginary':		if(bSetCoord)	g_parImag = parseFloat(value), g_bLocationSet = true; break;
					case 'Magnification':	if(bSetCoord)	g_parMagn = parseFloat(value), g_bLocationSet = true; break;
					default: 
						for (var i = 0; i < g_nColorsAvailable; i++)
						{
							if(name == 'color' + (i + 1))
							{
								if(bSetColors) g_parTemp.colors[i] = HexColorToNumber(value); 
								return true;
							}
						}
						return false;
				}
				return true;
			}

			  /////////////////////
			 // Hilfsfunktionen //
			/////////////////////

			//
			// Verkürzung der Schreibweise
			//
			function $(id)
			{
				return document.getElementById(id);
			}

			//
			// Wandelt einen Hexadezimal-String im Format "#XXXXXX" in eine Zahl um
			//
			function HexColorToNumber(hexColor)
			{
				return parseInt(hexColor.replace(/^#/, ''), 16);
			}

			//
			// Wandelt eine Zahl un einen Hexadezimal-String im Format "#XXXXXX" um
			//
			function NumberToHexColor(numColor)
			{
				return '#' + ('00000' + numColor.toString(16)).substr(-6).toUpperCase();
			}

			//
			// Hauptfunktion. Muss einmalig nach dem Laden der Seite aufgerufen werden.
			//
			function main()
			{
				Init();
				if(ReadParametersFromUrl()) Draw();
				else LoadExample('apple-cl');
			}

		</script>
	</head>

	<body onload="main();">

		<center>
			<form>
				<fieldset id="form">
					<span class="label" id="reLabel"></span><input id="reMin" type="text" style="width:150px;">...<input id="reMax" type="text" size="20" style="width:150px;">
					<span class="label" id="imLabel"></span><input id="imMin" type="text" style="width:150px;">...<input id="imMax" type="text" size="20" style="width:150px;">
					<span class="label" id="itMaxLabel"></span><input id="itMax" type="text" style="width:50px;">
					<span class="label" id="escRadiusLabel"></span><input id="escRadius" type="text" style="width:24px;">
					<span class="label" id="smoothingLabel"></span><input id="smoothing" type="checkbox">
					&nbsp;
					<span id="duration"></span>
					&nbsp;
					<span id="magnification"></span>
					<br>
					<input
						id="imgWidth" type="text" style="width:50px;"><span class="label">&times;</span><input 
						id="imgHeight" type="text" style="width:50px;"><span class="label">&times;</span><input 
						id="pxInterpolation" type="text" value="1" style="width:20px;"><span class="label">px</span>
					&nbsp;
					<select id="colorMode" onchange="SetDefaultColors(); Draw(true);">
						<script type="text/javascript">
							for (var i = 2; i <= g_nColorsAvailable; i++) document.write('<option value="gradient' + i + '">' + i + ' ' + g_strColors + '</option>');
							document.write('<option value="random">' + g_strRandom + '</option>');
						</script>
					</select>
					<script type="text/javascript">
						for (var i = 1; i <= g_nColorsAvailable; i++) document.write('<input id="color' + i + '" type="color" onchange="Draw(true);" title="' + g_strColorForGradient1 + (i) + g_strColorForGradient2 + '">');
					</script>
					&nbsp;
					<select id="linearity" onchange="Draw(true);" style="width:50px;">
						<option value="1" selected="true">lin</option>
						<option value="2">sin</option>
						<option value="3">auto</option>
						<option value="4">log</option>
						<option value="5">gam</option>
						<option value="6">tanh</option>
					</select><input
						id="linRange" type="range" min="0" max="100" oninput="OnChangeRange(); Paint();" style="width:112px;"><input
						id="linRangeOut" type="text" readonly style="width:35px; text-align:right;">
					&nbsp;
					<span class="label" id="colorCountLabel"></span><input id="colorCount" onchange="Draw(true);" type="text" style="width:30px;">
					&nbsp;
					<span class="label" id="colorCompressLabel"></span><input id="colorCompress" onchange="Draw(true);" type="checkbox">
					&nbsp;
					<span class="label" id="colorInvertLabel"></span><input id="colorInvert" onchange="Draw(true);" type="checkbox">
					&nbsp;
					<span class="label" id="repCountLabel"></span><input id="repCount" onchange="Draw(true);" type="text" style="width:30px;">
					&nbsp;
					<span class="label" id="cyclePaletteLabel"></span><input id="cyclePalette" onchange="Draw(true);" type="checkbox">
					&nbsp;
					<span class="label" id="reduceHaloLabel"></span><input id="reduceHalo" onchange="Draw(true);" type="checkbox">
					&nbsp;
					<span class="label" id="colorImaxLabel"></span><input id="colorImax" onchange="Draw(true);" type="color">
					<br>
					<input id="historyBack" type="button" value="&lt;&lt;" onclick="HistoryBack();" style="width:40px;">
					<input id="historyForward" type="button" value="&gt;&gt;" onclick="HistoryForward();" style="width:40px;">
					&nbsp;
					<input id="drawButton" type="button" onclick="OnButtonClickedDraw();" style="width:80px;">
					&nbsp;
					<span class="label" id="zoomLabel"></span>
					<input id="zoomOutButton" type="button" value="&ndash;" onclick="Zoom(0);" style="width:30px;">
					<input id="zoomInButton" type="button" value="+" onclick="Zoom(1);" style="width:30px;">
					<input id="zoomFactor" type="text" value="3" style="width:30px;">
					&nbsp;
					<span class="label" id="moveLabel"></span>
					<input id="moveLeftButton" type="button" value="&larr;" onclick="Move('L');" style="width:30px;">
					<input id="moveRightButton" type="button" value="&rarr;" onclick="Move('R');" style="width:30px;">
					<input id="moveUpButton" type="button" value="&uarr;" onclick="Move('U');" style="width:30px;">
					<input id="moveDownButton" type="button" value="&darr;" onclick="Move('D');" style="width:30px;">
					<input id="movePercent" type="text" value="10" style="width:30px;"><span class="label">%</span>
					&nbsp;
					<input id="linkButton" type="button" onclick="DisplayLink();" style="width:60px;">
					<input id="savePngButton" type="button" value="&gt; png" onclick="SavePng();" style="width:60px;">
					<input id="saveTxtButton" type="button" value="&gt; txt" onclick="SaveTxt();" style="width:60px;">
					<input id="readTxtButton" type="button" value="&lt; txt" onclick="$('popupTxt').style.display = 'block';" style="width:60px;">
					&nbsp;
					<span class="label" id="examplesLabel"></span>
					<select id="example" onchange="LoadExample(this.value);">
						<script type="text/javascript">document.write
						(
							'<option value="--">' + (g_english ? '(please select)' : '(bitte auswählen)') + '</option>' +
							'<option value="apple-bw">' + (g_english ? 'Apple (2 colors)' : 'Apfel (2-farbig)') + '</option>' +
							'<option value="apple-cl">' + (g_english ? 'Apple (colored)' : 'Apfel (bunt)') + '</option>' +
							'<option value="spiral-bw">' + (g_english ? 'Spiral (2 colors)' : 'Spirale (2-farbig)') + '</option>' +
							'<option value="spiral-cl">' + (g_english ? 'Spiral (colored)' : 'Spirale (bunt)') + '</option>' +
							'<option value="star">' + (g_english ? 'Star' : 'Stern') + '</option>' +
							'<option value="tree">' + (g_english ? 'Tree' : 'Baum') + '</option>' +
							'<option value="flower">' + (g_english ? 'Flower' : 'Blüte') + '</option>' +
							'<option value="butterfly">' + (g_english ? 'Butterfly' : 'Schmetterling') + '</option>' +
							'<option value="furryjulia">' + (g_english ? 'Furry Julia' : 'Fell-Julia') + '</option>' +
							'<option value="goldenjulia">' + (g_english ? 'Golden Julia' : 'Goldjulia') + '</option>' +
							'<option value="burningjulia">' + (g_english ? 'Burning Julia' : 'Brennende Julia') + '</option>'
						);
						</script>
					</select>
				</fieldset>
			</form>
		</center>
		<div id="popupTxt" style="display:none; position:absolute; left:60%; top:10%;">
			<form>
				<fieldset style="padding-left:20px; padding-right:20px;">
					<p><b><span id="readTxtFileLabel"></span></b></p>
					<p>
						<input id="txtParametersAll" name="txtParameters" type="radio" value="all" checked="checked" onclick="$('txtParFractal').checked = $('txtParFractalCoordOnly').checked = $('txtParGraphic').checked = $('txtParGraphicColorsOnly').checked = false; "><span class="label" id="allParametersLabel"></span><br>
						<input id="txtParametersSel" name="txtParameters" type="radio" value="sel"><span class="label" id="onlySelectedParametersLabel"></span><br>
						<input id="txtParFractal" type="checkbox" style="margin-left:20px;" onclick="$('txtParametersSel').checked = true; $('txtParFractalCoordOnly').checked &= this.checked;"><span class="label" id="fractalParametersLabel"></span><br>
						<input id="txtParFractalCoordOnly" type="checkbox" style="margin-left:40px;" onclick="$('txtParametersSel').checked = true; $('txtParFractal').checked |= this.checked;"><span class="label" id="onlyCoordinatesLabel"></span><br>
						<input id="txtParGraphic" type="checkbox" style="margin-left:20px;" onclick="$('txtParametersSel').checked = true; $('txtParGraphicColorsOnly').checked &= this.checked;"><span class="label" id="graphicsParametersLabel"></span><br>
						<input id="txtParGraphicColorsOnly" type="checkbox" style="margin-left:40px;" onclick="$('txtParametersSel').checked = true; $('txtParGraphic').checked |= this.checked;"><span class="label" id="onlyColorsLabel"></span>
					</p>
					<p align="center">
						<input id="okReadTxtButton" type="button" style="width:100px;" onclick="$('popupTxt').style.display = 'none'; $('filebrowser').click();">
						<input id="cancelReadTxtButton" type="button" style="width:100px;" onclick="$('popupTxt').style.display = 'none';">
					</p>
				</fieldset>
			</form>
			<div style="height:0px; width:0px; overflow:hidden; display:inline-block;"><input id="filebrowser" type="file" accept="text/plain" onchange="OpenTxt(event)"></div>
		</div>

		<center><canvas id="image"></canvas></center>

		<div id="helpGerman" style="display:none;">
			<h2 align="center">Hinweise zur Bedienung des Fraktalgrafik-Generators</h2>

			<p>Nach dem ersten Aufruf erscheint zunächt ein "Apfelmännchen" in vollständiger Ansicht.
			(Sollte dies nicht der Fall sein, ist vielleicht JavaScript im Browser deaktiviert.) Von hier ausgehend können durch
			Ausschnittsvergrößerungen oder "Hineinzoomen" die tieferen Strukturen der Fraktalgrafik erkundet werden. Dabei können
			die Farben nach Belieben angepasst werden. Auch der Wert I<sub>max</sub> sollte bei Bedarf erhöht werden, um bei starken
			Vergrößerungen mehr Details sichtbar zu machen. Wenn das Ergebnis gefällt, kann das Bild als PNG-Datei abgespeichert 
			werden. Zusätzlich können die Parameter zur Erstellung der Grafik in einer Textdatei gespeichert werden, um diese zu 
			einem späteren Zeitpunkt erneut einlesen und die Grafik zeichnen zu können. Schließlich kann auch noch ein Link erstellt 
			werden, nach dessen Aufruf die Grafik ebenfalls neu gezeichnet wird.</p>

			<p>Nachfolgend werden die einzelnen Parameter und Funktionen erklärt.
			Anschließend folgen noch einige zusätzliche Tipps und Hinweise.</p>

			<p>Wird der Mauszeiger über ein Eingabefeld oder einen Button bewegt, dann erscheint ein kurzer Hinweistext ("Tooltip") hierzu.</p>

			<h3 id="fraktalparameter">Fraktal-Parameter</h3>

			<p>Mit den Parametern in der obersten Reihe des Eingabeformulars wird der dargestellte Ausschnitt und der Detailreichtum der Mandelbrotmenge bestimmt.</p>

			<p>Re:<span class="input">-0.7956823317837173</span>...<span class="input">-0.79068056677067&nbsp;&nbsp;&nbsp;&nbsp;</span> = <b>Von- und Bis-Wert des Realteils</b> (x-Achse).</p>

			<p>Im:<span class="input">0.1590018671553155&nbsp;</span>...<span class="input">0.16275319091510096</span> = <b>Von- und Bis-Wert des Imaginärteils</b> (y-Achse).</p>

			<p>Zur Eingabe der Werte für Real- und Imaginärteil in diese 4 Felder bestehen folgende Möglichkeiten:</p>

			<ul>
				<li>Manuelle Eingabe (als Dezimaltrennzeichen dient hierbei ein Punkt!)</li>
				<li><a href="#maus">Ausschnittsbestimmung mit der Maus</a></li>
				<li><a href="#text">Einlesen einer Parameter-Textdatei</a></li>
				<li><a href="#link">Aufruf über einen Fraktalgrafik-Generator-Link</a></li>
				<li><a href="#beispiel">Auswahl eines vorgegebenen Beispiels</a></li>
			</ul>

			<p>Außerdem werden diese Werte noch durch die Funktionen "<a href="#zoom">Zoom</a>" und "<a href="#move">Verschieben</a>" verändert, sowie durch
			Vor- und Zurückspringen in der History (dazu unten mehr).</p>

			<p>I<sub>max</sub>:<span class="input">200&nbsp;&nbsp;&nbsp;</span> = <b>Maximale Anzahl von Iterationen</b> (wiederholten Berechnungen) pro Bildpunkt (Pixel),
			auch Iterationstiefe genannt. Je höher dieser Wert ist, umso mehr farbliche Abstufungen werden dargestellt.
			Wird dieser Wert erreicht, dann wird das entsprechende Pixel mit der Farbe für I<sub>max</sub> (s.u.) dargestellt
			(dies ist z.B. im Innern des "Apfelmännchens" der Fall).</p>

			<p>Je weiter man in die Fraktalgrafik hineinzoomt, umso höher sollte der hier angegebene Wert sein. Stellt man z.B.
			mit zunehmender Ausschnittsvergrößerung durch "Hineinzoomen" fest, dass größere "schwarze Flecken" sichtbar werden,
			kann man die Iterationstiefe z.B. in Schritten von 100 oder 1000 erhöhen, um wieder mehr Details zu sehen.
			Bei sehr hohen Vergrößerungen kann der Wert auch durchaus schonmal bei 50000 oder sogar 100000 liegen.
			Allerdings kann sich dadurch auch die Berechnungszeit für die Fraktalgrafik auf z.B. über 1 Minute erhöhen.</p>

			<p>Wird der Mauszeiger über das Eingabefeld gehalten, dann werden in einem Tooltip folgende Informationen angezeigt:</p>

			<ul>
				<li>Kleinste und größte Zahl der im Bild vorkommenden Iterationen (betrifft nur die Umgebung der Mandelbtotmenge)</li>
				<li>Angabe, ob die Mandelbtotmenge im Bild enthalten ist (Ja/Nein)</li>
			</ul>

			<p>Diese Angaben sind nützlich, wenn die Option "<a href="#kmp">Kmp</a>" (Farbpalette komprimieren) aktiviert ist. Ändert man nämlich
			die Bildgröße oder die Anzahl der Subpixel (s.u.), kann sich die Zahl der im Bild vorkommenden Iterationswerte und somit der Farbverlauf
			ändern. Um das zu vermeiden, kann I<sub>max</sub> auf die hier angezeigte größte vorkommende Iterationszahl gesetzt werden. Ist die
			Mandelbrotmenge im Bild enthalten, sollte dieser Wert noch um 1 erhöht werden.</p>

			<p>Rad:<span class="input">5&nbsp;&nbsp;&nbsp;</span> = <b>Fluchtradius</b>. Dies ist der Radius des Kreises um den Mittelpunkt der Gaußschen Zahlenebene, der darüber bestimmt, 
			ob ein Punkt zur Mandelbrotmenge gehört oder nicht. Normalerweise ist dieser Wert 2. Bei aktivierter Glättung sollte er jedoch mindestens 4 oder 5 betragen.</p>

			<p>DeBanding:<span class="input">&radic;</span> = <b>Farbübergänge glätten.</b> Zur Vermeidung sichtbarer Stufen zwischen den einzelnen Farben eines 
			Farbverlaufs kann der Farbverlauf optional geglättet werden. Hierzu wird der bei der Mandelbrot-Iteration Z=Z²+C ermittelte Iteratorwert mit Hilfe 
			der Formel "it = it + 2 - log(log(a²+b²)) / log(2)" von einem ganzzahligen in einen gebrochenen Wert umgerechnet, der abhängig ist von der 
			"Fluchtdistanz" bei Erreichen der Divergenz (nähere Erläuterungen dazu unter <a href="http://linas.org/art-gallery/escape/smooth.html" 
			target="_blank" rel="noopener">Smooth Shading for the Mandelbrot Exterior by Linas Vepstas</a>). Für einen guten Glättungs-Effekt sollte der Fluchtradius statt 
			des üblichen Wertes von 2 mindestens 4, besser 5 betragen.</p>

			<p><span style="color:blue;">t=4.464s</span> (Beispielwert) = Anzeige der für die Berechnung und das Zeichnen der Fraktalgrafik 
			<b>benötigten Zeitdauer</b> in Sekunden (in blauer Schrift).</p>

			<p><span style="color:green;">V=1.00&times;10<sup>0</sup></span> (Beispielwert) = Anzeige des <b>Vergrößerungsfaktors</b> in exponentieller
			Schreibweise (in grüner Schrift). Bei der vollständigen Ansicht der Mandelbrotmenge (Größe 4&times;4) beträgt der Vergrößerungsfaktor 1
			(angegeben als 1.00&times;10<sup>0</sup>). Je weiter in die Grafik "hineingezoomt" wurde, umso größer ist der hier angezeigte Wert.
			Ab einer Vergrößerung von ca. 33 Billionen (33&times;10<sup>12</sup>) stößt dieses einfache Programm allerdings an seine Grenzen, 
			da die maximale Genauigkeit der Gleitkommazahlen in JavaScript bei etwa 16 Stellen hinter dem Komma (bzw. dem Dezimalpunkt) liegt. 
			Bei weiterer Vergrößerung erscheinen die einzelnen Bildpunkte dann zunehmend als Linien bzw. Rechtecke.</p>

			<h3 id="grafikparameter">Grafik-Parameter</h3>

			<p>Die Parameter in der mittleren Reihe des Eingabeformulars bestimmen vor allem das farbliche Erscheinungsbild der zu erzeugenden Fraktalgrafik.</p>

			<p><span class="input">1200&nbsp;&nbsp;&nbsp;</span>&times;<span class="input">900&nbsp;&nbsp;&nbsp;&nbsp;</span>&times;<span class="input">1&nbsp;&nbsp;</span>px = 
			a) Horizontale und vertikale <b>Größe der zu erzeugenden Fraktalgrafik</b> in Pixeln, b) <b>Pixel-Interpolation</b>.

			<p>a) Die ersten beiden Werte legen die horizontale und vertikale Größe der erzeugten Fraktalgrafik fest.
			Die Angabe erfolgt in in Pixeln. Voreingestellt sind 1200 &times; 900 Pixel. Um z.B. ein Hintergrundbild für
			Bildschirme im HD-Format zu erzeugen, kann man hier 1920 &times; 1080 angeben (manche Computermonitore haben
			auch 1920 &times; 1200 Pixel).</p>

			<p>b) Der dritte Wert ist die Anzahl der "Subpixel" zur Berechnung eines Bildschirmpixels. Dies dient der "Kantenglättung"
			der erzeugten Fraktalgrafik. Hierzu wird jeder Bildpunkt in mehrere neben- und übereinander liegende "Subpixel"
			unterteilt. Für jedes dieser "Subpixel" wird ein eigener Farbwert berechnet. Die resultierende Farbe des Bildschirmpixels
			ergibt sich dann aus dem Durschschnittswert der Farben aller "Subpixel". Bei dem hier einzugebenden Wert handelt es sich 
			somit um die Seitenlänge eines virtuellen Quadrates, dessen Pixel zu einem Pixel interpoliert werden. Ein Wert von 3 bedeutet 
			z.B., dass jeder Bildpunkt in 3 &times; 3 = 9 Unterpunkte aufgeteilt wird. Für eine Grafik der Größe 1200 &times; 900 werden 
			also intern 3600 &times; 2700 Pixel berechnet. Dementsprechend erhöht sich auch die Berechnungszeit auf das 9-fache.</p>

			<p><span class="input">7 Farben&nbsp;&nbsp;&nbsp;</span><span class="button">V</span> &nbsp; 
			<span class="input" style="background-color:#FF0000; border-color:#000000;">&nbsp;&nbsp;</span>
			<span class="input" style="background-color:#FFFF00; border-color:#000000;">&nbsp;&nbsp;</span>
			<span class="input" style="background-color:#00FF00; border-color:#000000;">&nbsp;&nbsp;</span>
			<span class="input" style="background-color:#00FFFF; border-color:#000000;">&nbsp;&nbsp;</span>
			<span class="input" style="background-color:#0000FF; border-color:#000000;">&nbsp;&nbsp;</span>
			<span class="input" style="background-color:#FF00FF; border-color:#000000;">&nbsp;&nbsp;</span>
			<span class="input" style="background-color:#FF0000; border-color:#000000;">&nbsp;&nbsp;</span>
			= <b>Zu verwendende Farbpalette</b></p>

			<p>Hier erfolgt die Auswahl der zu verwendenden Farben, mit denen die Umgebung der Mandelbrotmenge gezeichnet werden soll.
			Es kann zwischen folgenden Paletten gewählt werden:</p>

			<ul>
				<li>
					<span class="input">2 Farben&nbsp;&nbsp;&nbsp;</span> bis <span class="input">7 Farben&nbsp;&nbsp;&nbsp;</span>: 
					Farbverlauf zwischen 2, 3, 4, 5, 6 oder 7 auswählbaren Farben.
					Je nachdem, welche dieser Paletten ausgewählt wird, werden die rechts daneben befindlichen Farbwahlfelder aktiviert
					und mit Standardfarben oder den zuletzt ausgewählten Farben vorbelegt. Nach Anklicken eines dieser Farbwahlfelder öffnet sich
					(abhängig vom Browser und vom Betriebssystem) ein Fenster zur Auswahl der Farbe.
					<br>&nbsp;
				</li>

				<li>
					<span class="input">Zufall&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>:
					Diese Palette enthält Zufallsfarben, die sich bei jedem erneuten Zeichnen ändern. Jedem Iterationswert ist dabei eine 
					bestimmte Zufallsfarbe zugeordnet. Da es hier keine Farbverläufe gibt, eignet sich diese Palette zur Hervorhebung der Höhenlinien.
				</li>
			</ul>

			<p><span class="input">log&nbsp;</span><span class="button">V</span> &nbsp;
			===<span class="input" style="background-color:#EEEEEE"></span>=========== &nbsp;
			<span class="input" style="background-color:#EEEEEE">&nbsp;&nbsp;&nbsp;2.00</span>
			= <b>Linearität des Farbverlaufs</b></p>

			<p>Über diese Dropdown-Box kann die Linearität des Farbverlaufs bestimmt werden. Normalerweise "drängen" sich die Farben in der Nähe 
			des Randes der Mandelbrot-Menge stärker als weiter weg davon, was zur Folge hat, dass die Umgebung der Mandelbrot-Menge etwas "einfarbig" erscheint. 
			Je nach Auswahl einer Linearität wird der Farbverlauf mehr oder weniger stark "entzerrt" und der untere Bereich der Iteratorwerte &ndash; also die 
			Bereiche, die sich weiter von der Mandelbrot-Menge entfernt befinden &ndash; farblich differenzierter dargestellt. Bei Auswahl von "log" (logarithmisch), 
			"gam" (Gamma) und "tanh" (Tangens Hyperbolicus) kann über den Schieberegler die Stärke der Entzerrung eingestellt werden. Dessen Wert wird rechts daneben 
			auch als Zahl angezeigt.</p>

			<ul>
				<li><b>lin</b> (linear): Keine Entzerrung des Farbverlaufs.</li>
				<li><b>sin</b> (sinusförmig): Die Entzerrung erfolgt anhand der Funktion <span class="formula">y = sin(x * Pi / 2)</span> mit x = Eingangswert (0...1) und y = Ausgangswert (0...1). Der Kurvenverlauf entspricht somit dem ersten Viertel einer Sinuskurve. Die Wirkung ist im Vergleich zu den vier nachfolgenden eher gering.</li>
				<li><b>auto</b> (automatisch): Die Stärke der Entzerrung wird automatisch bestimmt und ist abhängig von der Anzahl der gleichzeitig im Bild sichtbaren Farben: Viele Farben = starke Entzerrung, wenige Farben = schwache Entzerrung. Die Formel dazu lautet <span class="formula">y = (log(it) - log(minIt)) / (log(maxIt) - log(minIt))</span> mit it = Anzahl Iterationen, minIt = kleinste Iterationszahl im Bild und maxIt = größte Iterationszahl im Bild.</li>
				<li><b>log</b> (logarithmisch): Die Entzerrung erfolgt anhand der logarithmischen Funktion <span class="formula">y = log(x * 4<sup>Faktor</sup> + 1) / log(4<sup>Faktor</sup> + 1)</span> mit Faktor = 0...10 (Stellung des Schiebereglers).</li>
				<li><b>gam</b> (Gamma): Die Entzerrung erfolgt anhand der Gamma-Funktion <span class="formula">y = x<sup>1 / Gamma</sup></span> mit Gamma = 0,001...10 (Stellung des Schiebereglers). Die "Gamma"-Entzerrung ergibt etwas "weichere" Farbverläufe als "log" (logarithmisch).</li>
				<li><b>tanh</b> (Tangens Hyperbolicus): Die Entzerrung erfolgt anhand der Formel <span class="formula">y = tanh(n * x) / tanh(n)</span> mit n = 0...10 (Stellung des Schiebereglers). Die "tanh"-Kurve ist steiler als bei "log" (logarithmisch) und ergibt daher höhere Kontraste.</li>
			</ul>

			<p>Einige Beispielbilder für die oben aufgeführten Methoden zur Entzerrung des Farbverlaufs befinden sich auf der Seite 
			<a href="colormapping/index.htm">Color Mapping</a> (englischsprachig).</p>

			<p>Anz:<span class="input">0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span> = <b>Anzahl der darzustellenden unterschiedlichen Farben.</b>
			Hiermit kann die Anzahl der verschiedenen auszugebenden Farben
			auf einen bestimmten Wert begrenzt werden. Der Wert 0 bedeutet: Keine Beschränkung, es werden alle möglichen Farben der gewählten Palette
			dargestellt. Dadurch ergeben sich sanfte Farbübergänge und feine Details werden sichtbar. Ein Wert ab 2 bedeutet, dass aus der gewählten 
			Palette nur diese Anzahl von Farben benutzt werden, um das Bild zu zeichnen. Je kleiner dieser Wert ist, umso "stufiger" wird der Farbverlauf 
			und umso mehr treten die "Höhenlinien" hervor, allerdings gehen dann auch die feinen Details im "Bildrauschen" zunehmend unter. 
			Bei dem kleinsten erlaubten Wert von 2 wird beispielsweise nur die erste und die letzte Farbe der gewählten Palette verwendet. 
			Diese Angabe gilt nicht für die Farbpalette "Zufall" und auch nicht bei Auswahl der Linearität "Automatisch".</p>

			<p id="kmp">Kmp:<span class="input">&radic;</span> = <b>Farbpalette komprimieren.</b> Ein Setzen dieses Häkchens bewirkt, dass alle Farben der gewählten Palette im Bild erscheinen.
			Normalerweise wird die Farbpalette gleichmäßig auf den gesamten Iterationsbereich aufgeteilt, d.h. die Bildpunkte mit 1 Iteration bekommen die 1. Farbe und die Bildpunkte mit 
			199 Iterationen (bei I<sub>max</sub> = 200) die letzte Farbe. Ist nun bei tieferem Hineinzoomen in die Fraktalgrafik nicht mehr der gesamte Iterationsbereich im Bild 
			sichtbar, weil z.B. die Bildpunkte mit 1 bis 50 Iterationen nicht mehr im Bild erscheinen, dann fehlen die unteren 25% der Farben im Bild. Durch Setzen dieser Option wird 
			bewirkt, dass die Farbpalette immer auf alle im Bild vorkommenden Iterationszahlen aufgeteilt wird &ndash; in diesem Beispiel also auf die Bildpunkte mit den Iterationszahlen 
			51 bis 199. Diese Angabe gilt nicht für die Farbpalette "Zufall" und auch nicht bei Auswahl der Linearität "Automatisch".</p>

			<p>Umk:<span class="input">&radic;</span> = <b>Reihenfolge der Farben der gewählten Palette umkehren.</b> 
			Ist z.B. die erste Farbe der Palette Rot und die letzte Grün, dann bewirkt ein Setzen dieses Häkchens, dass im Bild Grün zuerst und Rot 
			zuletzt kommt. Diese Angabe gilt nicht für die Farbpalette "Zufall".</p>

			<p>Wdh:<span class="input">1&nbsp;&nbsp;&nbsp;&nbsp;</span> = <b>Anzahl der Wiederholungen der Farbpalette.</b>
			Gibt an, wie oft die Farben der gewählten Palette über den gesamten Itertationsbereich hinweg wiederholt werden. Der Wert muss mindestens 
			1 betragen. Je höher der Wert, umso öfter kommt die Farbfolge im Bild vor. Beispiel: Bei einer dreifarbigen Palette mit den Farben 
			Rot, Gelb und Grün und 2 Wiederholungen erscheint im Bild die Farbfolge "Rot, Gelb, Grün, Rot, Gelb, Grün".
			Diese Angabe gilt nur für die Farbpaletten "2 Farben" bis "7 Farben".</p>

			<p>Alt:<span class="input">&radic;</span> = <b>Richtung der Farbpalette alternieren.</b> 
			Diese Einstellung bewirkt, dass sich bei Wiederholungen der Farbpaletten (Wdh > 1) die Reihenfolge der Farben abwechselnd ändert. 
			Beispiel: Bei einer dreifarbigen Palette mit den Farben Rot, Gelb und Grün und 3 Wiederholungen erscheint im Bild die Farbfolge 
			"Rot, Gelb, Grün, Gelb, Rot, Gelb, Grün". Diese Option ist vor allem für Farbpaletten sinnvoll, deren erste und letzte Farbe 
			verschiedenen sind. Bei nicht aktivierter Option würde es an den Stellen zwischen den Wiederholungen zu harten "Farbsprüngen" kommen.
			Diese Option gilt nur für die Farbpaletten "2 Farben" bis "7 Farben" und wenn die Anzahl der Wiederholungen mindestens 2 beträgt.</p>

			<p>DeHalo:<span class="input">&radic;</span> = <b>Farbsäume reduzieren.</b>
			Manchmal kommt es bei Farbverläufen zu sichbaren Farbsäumen zwischen zwei benachbarten Farben.
			Dies kann ein erwünschter Effekt sein, es kann jedoch auch störend wirken.
			Bei aktivierter Option wird statt des linearen Übergangs zwischen zwei Farben ein sinusförmiger Übergang verwendet.
			Hierdurch werden die Übergänge zwischen zwei benachbarten Farben etwas fließender, wodurch der Farbsaum verschwindet.
			Insgesamt wird das Bild dadurch "weicher".
			(Mehr Hintergrundinformationen zu diesem Thema auf <a href="colormapping/index.htm#PaletteInterpolation">dieser Seite</a>.)
			Diese Angabe gilt nur für die Farbpaletten "2 Farben" bis "7 Farben".</p>

			<p>I<sub>max</sub>:<span class="input" style="background-color:#000000; border-color:#000000;">&nbsp;&nbsp;</span> = 
			<b>Farbe für Iterationsgrenze.</b> Hier kann die Farbe für die Pixel gewählt werden, deren Anzahl Iterationen dem Wert I<sub>max</sub>
			entspricht, was z.B. beim "Inneren" des "Apfels" der Fall ist. Standardmäßig ist diese Farbe auf Schwarz gesetzt, aber durch Anklicken
			dieses Farbwahlfeldes kann hierfür auch eine beliebige andere Farbe gewählt werden.</p>

			<h3>Funktionen</h3>

			<p id="maus"><b>Ausschnittsbestimmung per Maus</b>: Hierzu einfach mit gedrückter gehaltener linker Maustaste einen rechteckigen Bildausschnitt
			markieren. Wird dabei die Strg-Taste gedrückt, dann entspricht der erste Mausklick dem Mittelpunkt des Ausschnitts. 
			Die dem gewählten Ausschnitt entsprechenden Werte für Real- und Imaginärteil werden danach in den Eingabefeldern gelb hinterlegt
			angezeigt. Nach Betätigung des Buttons [Zeichnen] wird dann eine neue Grafik mit dem gewählten Ausschnitt gezeichnet. Um die Markierung 
			zu entfernen, genügt ein einfacher Klick in das Bild.</p>

			<p>In der untersten Reihe des Eingabeformulars befinden sich verschiedene Buttons zur Steuerung des Fraktalgrafik-Generators:</p>

			<p><span class="button">&lt;&lt;</span> (Zurück) und <span class="button">&gt;&gt;</span> (Vorwärts) = <b>History (Verlauf):</b> 
			Mit Hilfe dieser Buttons kann &ndash; ähnlich wie bei einem Web-Browser &ndash; durch die "History" (Verlauf) der gezeichneten Grafiken 
			gesprungen werden. Nach Anklicken eines dieser Buttons werden die Parameter der zuvor bzw. danach gezeichneten Bilder in die Eingabefelder 
			geladen. Das Bild wird noch nicht sofort gezeichnet; hierzu muss der Button [Zeichnen] angeklickt werden. Jedes Zeichnen mit veränderten
			Parametern erzeugt einen neuen History-Eintrag ab der aktuell ausgewählten Verlaufsposition. Ggf. vorhandene nachfolgende Einträge
			werden dabei gelöscht.</p>

			<p><span class="button">Zeichnen</span>: <b>Zeichnet die Grafik</b> mit den angegebenen Parametern. Während des Bild gezeichnet wird, lautet die
			Bezeichnung dieses Buttons "Stop". Durch eine Klick darauf kann eine länger dauernde Grafikerstellung abgebrochen werden. Falls
			seit dem letzten Zeichnen nur die Farbeinstellungen geändert wurden, aber nicht die übrigen Parameter, dann wird die Fraktalgrafik 
			nicht erneut berechnet, sondern nur neu gezeichnet, was wesentlich schneller geht als eine komplette Neuberechnung. So kann man 
			nach Belieben mit den Farben herumexperimentieren, ohne jedesmal lange auf das Ergebnis warten zu müssen.</p>

			<p id="zoom">Zoom: <span class="button">&ndash;</span> <span class="button">+</span> <span class="input">3&nbsp;&nbsp;&nbsp;&nbsp;</span> = <b>Zoom-Funktion:</b>
			Mit Hilfe dieser Buttons kann der dargestellte Ausschnitt aus der Mandelbrotmenge
			verkleinert oder vergrößert werden, was einem "Herauszoomen" aus dem Bild bzw. einem "Hineinzoomen" in das Bild entspricht.
			Die Zahl im Eingabefeld rechts neben diesen beiden Buttons gibt den "Zoom-Faktor" an, also den Faktor, um den der
			Ausschnitt verkleinert oder vergrößert wird. Voreingestellt ist 3, d.h. beim Herauszoomen wird der Ausschnitt um den Faktor 3
			verkleinert, beim Hineinzoomen um den Faktor 3 vergrößert. Es können beliebige Werte angegeben werden, also z.B. auch 10 oder 100,
			aber auch "krumme" Werte wie 1.5 (wichtig ist hierbei, als Dezimaltrennzeichen einen Punkt statt eines Kommas einzugeben).</p>

			<p id="move">Verschieben: <span class="button">&larr;</span> <span class="button">&rarr;</span> <span class="button">&uarr;</span> <span class="button">&darr;</span>
			<span class="input">10&nbsp;&nbsp;&nbsp;&nbsp;</span>% = <b>Verschiebe-Funktion:</b>
			Mit diesen vier Buttons kann der dargestellte Bildausschnitt nach links, rechts, oben oder unten verschoben werden. Die Prozenzzahl im Eingabefeld
			rechts neben diesen vier Buttons gibt an, um welche Betrag der Ausschnitt verschoben werden soll. Der Wert bezieht sich auf 
			die Abmessungen des Bildes. Beispielsweise wird der Aussschnitt bei einem Wert von 10% und einer Bildbreite von 1200 Pixeln 
			um 120 Pixel nach links oder rechts verschoben.</p>

			<p id="link"><span class="button">Link</span> = <b>Link zu dieser Grafik erzeugen.</b> Nach Anklicken dieses Buttons öffnet sich ein Fenster mit einer URL
			zum Fraktalgrafik-Generator mit den aktuellen Parametern zum Zeichnen der Fraktalgrafik. Wird diese URL in einem Web-Browser
			aufgerufen, dann wird die Grafik mit den enthaltenen Parametern sofort gezeichnt.
			Mittels der Tastenkombination &lt;Strg&gt;&lt;C&gt; kann die URL aus dem Eingabefeld des Fensters in die Zwischenablage
			kopiert werden, um sie z.B. in einer E-Mail zu versenden, in einem Forum zu posten oder auf einer Webseite zu verlinken.
			Der Button [OK] öffnet die URL zu Testzwecken in einem neuen Browser-Tab. Der Button [Abbrechen] schließt das Fenster wieder.</p>

			<p><span class="button">&gt; png</span> = <b>Grafik als PNG-Datei abspeichern.</b> Nach Anklicken dieses Buttons öffnet sich ein Download-Dialog
			zum Abspeichern der Bilddatei (falls nicht, siehe "Tipps und Hinweise" unten). Leider wird hierbei keine Dateiendung vorgegeben,
			daher bitte darauf achten, an den eingegebenen Dateinamen die Endung ".png" anzuhängen! Alternativ kann das Bild auch duch 
			Rechtsklick und Auswahl von "Grafik speichern unter..." abgespeichert werden. Hierbei schlägt Firefox den Namen "canvas.png" vor.</p>

			<p><span class="button">&gt; txt</span> = <b>Parameter als Textdatei abspeichern.</b> Diese Datei enthält die zum Zeichnen der Mandelbrot-Bildes
			verwendeten Fraktal- und Grafik-Parameter. Hat man z.B. einen schönen Ausschnitt gefunden, kann man sich die Parameterdatei zur
			späteren Verwendung abspeichern oder einem anderen Benutzer dieses Programms schicken. Nach Anklicken dieses Buttons öffnet sich 
			ein Download-Dialog zum Abspeichern der Textdatei (falls nicht, siehe "Tipps und Hinweise" unten). Leider wird hierbei keine 
			Dateiendung vorgegeben, daher bitte darauf achten, an den eingegebenen Dateinamen die Endung ".txt" anzuhängen!</p>

			<p id="text"><span class="button">&lt; txt</span> = <b>Textdatei mit Parametern einlesen.</b> Hier kann eine zuvor abgespeicherte Parameter-Textdatei
			wieder eingelesen werden. Nach Anklicken dieses Buttons öffnet sich zuerst ein Dialog zur Auswahl der einzulesenden Parameter. 
			Es können alle Parameter oder auch nur ein Teil der Parameter eingelesen werden (z.B. nur die Farben).
			Nach Klick auf [OK] wird die Textdatei eingelesen und die Eingabefelder mit den ausgewählten Werten aus der Datei ausgefüllt.
			Nach Klick auf [Zeichnen] wird dann die Fraktalgrafik mit den aktuell gesetzten Parametern erzeugt.</p>

			<p>(Tipp: Die Parameter "Real", "Imaginary" und "Magnification" in der Textdatei sind alternative Angaben zur Bestimmung des Aussschnitts 
			aus der Fraktalgrafik zur Verwendung mit anderen Fraktalgrafik-Programmen wie "Fractal eXtreme" oder "Ultra Fractal". Sie werden vom 
			JavaScript-Fraktalgrafik-Generator nur interpretiert, wenn die Parameter "reMin", "reMax", "imMin" und "imMax" in der Textdatei fehlen. 
			Dies ermöglicht den Austausch dieser Parameter zwischen dem JavaScript-Fraktalgrafik-Generator und anderen Programmen, die diese alternative 
			Schreibweise zur Bestimmung des Aussschnitts verwenden.)</p>

			<p id="beispiel">Beispiele: <span class="input">(bitte auswählen)</span><span class="button">V</span> = <b>Auswahl einiger Beispiele</b>.
			Hier stehen einige Beispiel-Fraktale zum Ausprobieren bereit. Nach Auswahl eines Eintrages aus der Dropdown-Box
			werden die dazugehörigen Parameter in die Eingabefelder geladen und die Beispiel-Fraktalgrafik erzeugt.</p>

			<h3>Tipps und Hinweise</h3>

			<p>Diese JavaScript-Anwendung erfordert einen modernen Browser mit <b>HTML5</b>-Unterstützung. Getestet wurde sie in Firefox 46, Chrome 49, 
			Opera 36 und Internet Explorer 11. Letzterer Browser zeigt statt der Farbwahlfelder leider nur normale Eingabefelder mit dem Hexcode der 
			Farbe (z.B. "#FF0000").</p>

			<p><b>JavaScript</b> muss natürlich in den Browser-Einstellungen aktiviert bzw. über entsprechende Add-ons wie "NoScript" zugelasen sein.</p>

			<p>Falls beim Speichern der PNG- oder TXT-Dateien kein <b>Download-Dialog</b> ("Speichern unter" etc.) zur Angabe des Speicherortes 
			und des Dateinamens erscheint, sondern die Datei stattdessen automatisch in einem vorgegebenen Download-Ordner landet, dann kann dies 
			in den Browser-Einstellungen wie folgt geändert werden (hier Beispiele für 3 Browser - bei den anderen wird es ähnlich sein):</p>

			<ul>
				<li><b>Chrome:</b> Menü > Einstellungen > Erweiterte Einstellungen anzeigen > Downloads: Vor dem Download von Dateien nach dem Speicherort fragen [&radic;]</li>
				<li><b>Opera:</b> Menü > Settings > Basic > Downloads > [&radic;] Ask where to save each file before downloading</li>
				<li><b>Firefox:</b> Menü > Einstellungen > Allgemein > Downloads: (&bull;) Jedes Mal nachfragen, wo eine Datei gespeichert werden soll</li>
			</ul>

			<p>Dieses Script kann frei verwendet werden. Der gesamte <b>Quellcode</b> ist in der vorliegenden HTML-Datei enthalten und kann auch
			lokal abgespeichert und "offline" in einem Browser geöffnet und benutzt werden.</p>

			<h3>Versionsgeschichte</h3>
		</div>

		<div id="helpEnglish" style="display:none;">
			<h2 align="center">Instructions for operating the Fractal Graphics Generator</h2>

			<h3>TODO</h3>

			<p>The English translation of the operating instructions is in progress! Until I have finished it, you can use the tooltips 
			which appear when you hold the mouse cursor over the UI elements (input fields, check boxes, dropdown boxes, buttons).</p>

			<p></p>

			<p></p>

			<p><a href="" onclick="$('helpGerman').style.display = 'block'; $('helpEnglish').style.display = 'none'; return false;">Click here</a> to display the German instructions.</p>

			<h3>Version History</h3>
		</div>

		<h4>20.03.2017</h4>

		<ul>
			<li>Erstveröffentlichung.</li>
		</ul>

		<h4>21.03.2017</h4>

		<ul>
			<li>Neu: Funktion "Link" (Link zur Grafik erzeugen).</li>
		</ul>

		<h4>24.03.2017</h4>

		<ul>
			<li>Neu: Farbverläufe aus bis zu 7 frei wählbaren Einzelfarben; dafür Wegfall der fest vorgegebenen Paletten "Regenbogen" und "Einfarbig".</li>
			<li>Neu: Optionen "Wdh" (Anzahl der Wiederholungen der Farbpalette) und "Alt" (Richtung der Farbpalette alternieren).</li>
		</ul>

		<h4>06.04.2017</h4>

		<ul>
			<li>Bugfix: Änderungen der Farbe "I<sub>max</sub>" wurden (unter anderem) beim Wechsel der Palette und beim Navigieren in der History "vergessen".</li>
			<li>Geändert: Beispiele aktualisiert (Farben angepasst)</li>
		</ul>

		<h4>13.04.2017</h4>

		<ul>
			<li>Bugfix: Falsche Ermittlung der Mausposition, wenn die Seite gescrollt wurde.</li>
		</ul>

		<h4>01.05.2017</h4>

		<ul>
			<li>Neu: Parameter "Rad" (Fluchtradius).</li>
			<li>Neu: Option "DeBanding" (Farbübergänge glätten).</li>
			<li>Entfernt: Farbpalette "Kunterbunt".</li>
			<li>Neu: Auswahl der Linearität des Farbverlaufs.</li>
			<li>Neu: Option "Kmp" (Farbpalette komprimieren).</li>
		</ul>

		<h4>26.11.2017</h4>

		<ul>
			<li>Neu: Option "DeHalo" (Farbsäume reduzieren).</li>
		</ul>

		<h4>04.02.2018</h4>

		<ul>
			<li>Neu: Dialog zur Auswahl der Parameter beim Einlesen einer Textdatei.</li>
		</ul>

		<h4>08.02.2018</h4>

		<ul>
			<li>Geändert: Textdatei speichern (alternative Parameter für den Ausschnitt aus der Fraktalgrafik).</li>
		</ul>

		<h4>21.02.2018</h4>

		<ul>
			<li>Geändert: Tooltip für Eingabefeld "I<sub>max</sub>" zeigt u.a. die Anzahl der im Bild vorkommenden Iterationen an.</li>
		</ul>

		<h4>28.02.2018</h4>

		<ul>
			<li>Geändert: Englische UI-Texte</li>
		</ul>

		<p align="center"><br>Zum Hauptartikel:<br>[<a href="index.htm">Das &raquo;Apfelmännchen&laquo; in JavaScript</a>]<br>&nbsp;</p>

	</body>
</html>
